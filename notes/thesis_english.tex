\documentclass[12pt,letterpaper,oneside]{book}

% ============================================================================
% PACKAGES
% ============================================================================
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,calc,decorations.pathreplacing}
\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{geometry}
\geometry{left=3cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\usepackage{setspace}
\onehalfspacing

% ============================================================================
% CODE LISTING CONFIGURATION
% ============================================================================
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{wolfram}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstdefinestyle{cpp}{
    language=C++,
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    morekeywords={size_t,uint8_t,mint,std}
}

\lstdefinestyle{bytecode}{
    backgroundcolor=\color{backcolour},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    numbers=left,
    numberstyle=\tiny\color{codegray},
    showspaces=false,
    showstringspaces=false,
    tabsize=2
}

\lstset{style=wolfram}

% ============================================================================
% THEOREM ENVIRONMENTS
% ============================================================================
\newtheorem{definition}{Definition}[chapter]
\newtheorem{example}{Example}[chapter]
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}{Lemma}[chapter]

% ============================================================================
% METADATA
% ============================================================================
\title{A Virtual Machine for the Wolfram Language Pattern Matcher}
\author{Héctor Daniel Sanchez Domínguez}
\date{January 2026}

% ============================================================================
% DOCUMENT
% ============================================================================
\begin{document}

% ============================================================================
% FRONT MATTER
% ============================================================================
\frontmatter

\maketitle

% Title page with thesis information
\thispagestyle{empty}
\vspace*{2cm}
\begin{center}
{\Large\bfseries A Virtual Machine for the Wolfram Language Pattern Matcher}

\vspace{1cm}

A thesis submitted in partial fulfillment\\
of the requirements for the degree of

\vspace{0.5cm}

{\large Master of Science in Computer Science}

\vspace{1cm}

by

\vspace{0.5cm}

{\large Héctor Daniel Sanchez Domínguez}

\vspace{1cm}

\textbf{Advisor:} Héctor Andrés Melgar Sasieta

\vspace{2cm}

% TODO: Add university name and logo
Universidad Nacional Autónoma de México\\
Facultad de Ciencias

\vspace{1cm}

January 2026
\end{center}
\newpage

% ----------------------------------------------------------------------------
% Abstract
% ----------------------------------------------------------------------------
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

Pattern matching is a fundamental feature of Wolfram Language that enables identification and manipulation of symbolic expressions based on their structure. However, evaluation of complex patterns can be computationally expensive when performed in an interpreted manner.

This thesis presents the design and implementation of a register-based virtual machine for efficient compilation and execution of Wolfram Language patterns. The system compiles patterns to bytecode that can be executed multiple times, amortizing compilation cost over repeated pattern matching operations.

The main contributions include:
\begin{itemize}
    \item A minimal instruction set (20 opcodes) designed specifically for pattern matching operations
    \item A structured backtracking mechanism based on the Warren Abstract Machine (WAM) for handling alternatives using choice points and trail
    \item A register-based architecture that avoids stack manipulation overhead while providing clear semantics through register conventions
    \item Complete support for nested patterns, repeated variables, alternatives, and pattern tests
    \item Semantic equivalence with native \texttt{MatchQ} for all supported pattern types
\end{itemize}

The implementation consists of approximately 3,250 lines of C++ and 650 lines of Wolfram Language code, integrated through LibraryLink. A comprehensive test suite with over 40 test cases verifies system correctness through equivalence testing with native \texttt{MatchQ}.

The evaluation focuses on intrinsic metrics rather than comparative benchmarks, measuring bytecode characteristics (instruction count, register usage), execution metrics (cycles executed, backtracking events), and memory footprint. The system successfully demonstrates that pattern matching can be compiled to a minimal, well-structured instruction set and executed with explicit backtracking control.

\vspace{1cm}
\noindent\textbf{Keywords:} Virtual machines, pattern matching, compilers, Wolfram Language, backtracking, Warren Abstract Machine

% ----------------------------------------------------------------------------
% Acknowledgments
% ----------------------------------------------------------------------------
\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

I would like to express my sincere gratitude to my advisor, Dr. Héctor Andrés Melgar Sasieta, for his guidance, support, and invaluable insights throughout this research.

% TODO: Add more acknowledgments

\tableofcontents
\listoffigures
\listoftables

% ============================================================================
% MAIN MATTER
% ============================================================================
\mainmatter

% NOTE: Chapters 1-3 are as before (Introduction, Fundamentals, Design)
% I'll now add the expanded Chapter 4: Implementation

% ============================================================================
% CHAPTER 4: IMPLEMENTATION
% ============================================================================
\chapter{Implementation}
\label{chap:implementation}

This chapter describes the implementation details of the pattern matching virtual machine, including the compiler, runtime system, and integration with Wolfram Language. The implementation comprises approximately 3,900 lines of code split between C++ (low-level runtime) and Wolfram Language (high-level interface).

% ----------------------------------------------------------------------------
\section{System Architecture}
\label{sec:system_architecture}

\subsection{Overview}

The system follows a layered architecture with clear separation of concerns:

\begin{figure}[ht]
\centering
\begin{tikzpicture}[
    layer/.style={rectangle, draw, minimum width=10cm, minimum height=1.2cm, align=center, fill=blue!20},
    sublayer/.style={rectangle, draw, minimum width=4.5cm, minimum height=0.8cm, align=center, fill=green!15},
    arrow/.style={->, >=stealth, thick}
]
    \node[layer] (wl) at (0,0) {\textbf{Wolfram Language Interface Layer} (650 LOC)};
    \node[sublayer, below=0.3cm of wl, xshift=-2.5cm] (wl1) {PatternMatcherExecute};
    \node[sublayer, below=0.3cm of wl, xshift=2.5cm] (wl2) {CompilePatternToBytecode};
    
    \node[layer, below=1.8cm of wl] (link) {\textbf{LibraryLink Integration} (200 LOC)};
    
    \node[layer, below=0.8cm of link] (cpp) {\textbf{C++ Core Layer} (3,250 LOC)};
    \node[sublayer, below=0.3cm of cpp, xshift=-2.5cm] (cpp1) {Compiler};
    \node[sublayer, below=0.3cm of cpp, xshift=2.5cm] (cpp2) {Virtual Machine};
    
    \node[layer, below=1.8cm of cpp] (ast) {\textbf{AST Layer} (400 LOC)};
    
    \draw[arrow] (wl1) -- (link);
    \draw[arrow] (wl2) -- (link);
    \draw[arrow] (link) -- (cpp);
    \draw[arrow] (cpp1) -- (ast);
    \draw[arrow] (cpp2) -- (ast);
\end{tikzpicture}
\caption{System architecture showing layered design}
\label{fig:system_layers}
\end{figure}

\subsection{Module Organization}

The codebase is organized as follows:

\begin{description}
    \item[\texttt{src/AST/}] Abstract syntax tree representation
    \begin{itemize}
        \item \texttt{MExpr.h/cpp}: Base expression classes
        \item \texttt{MExprLiteral.cpp}: Literal expressions (numbers, strings)
        \item \texttt{MExprSymbol.cpp}: Symbolic expressions
        \item \texttt{MExprNormal.cpp}: Structured expressions \texttt{f[a,b,c]}
        \item \texttt{MExprPatternTools.h/cpp}: Pattern utilities
    \end{itemize}
    
    \item[\texttt{src/VM/}] Virtual machine and compiler
    \begin{itemize}
        \item \texttt{Opcode.h/cpp}: Instruction set definition
        \item \texttt{PatternBytecode.h/cpp}: Bytecode representation
        \item \texttt{CompilePatternToBytecode.h/cpp}: Pattern compiler
        \item \texttt{VirtualMachine.h/cpp}: Execution engine
    \end{itemize}
    
    \item[\texttt{src/}] Core infrastructure
    \begin{itemize}
        \item \texttt{Expr.h/cpp}: Wolfram \texttt{Expr} wrapper
        \item \texttt{LibraryLink.cpp}: Wolfram integration
        \item \texttt{Embeddable.h}: Object factory for Wolfram objects
    \end{itemize}
    
    \item[\texttt{PatternMatcher/Kernel/}] Wolfram Language interface
    \begin{itemize}
        \item \texttt{FrontEnd/}: User-facing compilation interface
        \item \texttt{BackEnd/}: VM control and execution
        \item \texttt{Library/}: LibraryLink bindings
    \end{itemize}
\end{description}

% ----------------------------------------------------------------------------
\section{Internal Representation (MExpr)}
\label{sec:mexpr}

\subsection{Design Philosophy}

The \texttt{MExpr} (Internal Expression) system provides a C++-native representation of Wolfram Language expressions, enabling efficient manipulation without crossing the LibraryLink boundary repeatedly.

\begin{lstlisting}[style=cpp,caption={MExpr class hierarchy}]
class MExpr {
public:
    enum Kind { Literal, Symbol, Normal };
    
    virtual ~MExpr() = default;
    virtual Expr getExpr() const = 0;
    virtual Kind getKind() const = 0;
    virtual std::string toString() const = 0;
};

class MExprLiteral : public MExpr {
    Expr literal;  // Integer, Real, String, etc.
public:
    explicit MExprLiteral(Expr lit);
    Kind getKind() const override { return Kind::Literal; }
};

class MExprSymbol : public MExpr {
    std::string name;
public:
    explicit MExprSymbol(std::string n);
    Kind getKind() const override { return Kind::Symbol; }
    const std::string& getName() const { return name; }
};

class MExprNormal : public MExpr {
    std::shared_ptr<MExpr> head;
    std::vector<std::shared_ptr<MExpr>> children;
public:
    MExprNormal(std::shared_ptr<MExpr> h, 
                std::vector<std::shared_ptr<MExpr>> c);
    Kind getKind() const override { return Kind::Normal; }
    
    size_t length() const { return children.size(); }
    std::shared_ptr<MExpr> part(size_t i) const;
    std::shared_ptr<MExpr> getHead() const { return head; }
};
\end{lstlisting}

\subsection{Conversion from Wolfram Expressions}

The system converts Wolfram \texttt{Expr} objects to \texttt{MExpr} recursively:

\begin{lstlisting}[style=cpp,caption={Converting Expr to MExpr}]
std::shared_ptr<MExpr> MExpr::fromExpr(const Expr& expr) {
    if (expr.isInteger() || expr.isReal() || expr.isString()) {
        return std::make_shared<MExprLiteral>(expr);
    }
    
    if (expr.symbolQ()) {
        return std::make_shared<MExprSymbol>(expr.toString());
    }
    
    // Normal expression f[a, b, c]
    Expr head = expr.head();
    std::shared_ptr<MExpr> headMExpr = fromExpr(head);
    
    std::vector<std::shared_ptr<MExpr>> children;
    for (mint i = 1; i <= expr.length(); ++i) {
        children.push_back(fromExpr(expr.part(i)));
    }
    
    return std::make_shared<MExprNormal>(headMExpr, children);
}
\end{lstlisting}

\textbf{Design rationale:} This design allows the compiler to work with C++ smart pointers and STL containers rather than repeatedly calling LibraryLink functions, improving performance and code clarity.

% ----------------------------------------------------------------------------
\section{Pattern Compiler}
\label{sec:pattern_compiler_impl}

\subsection{Compiler State}

The compiler maintains state through the \texttt{CompilerState} structure:

\begin{lstlisting}[style=cpp,caption={CompilerState structure}]
struct CompilerState {
    // Register allocation
    ExprRegIndex nextExprReg = 1;  // %e0 reserved for current value
    BoolRegIndex nextBoolReg = 1;  // %b0 reserved for result
    
    // Label generation
    Label nextLabel = 0;
    
    // Lexical environment (variable name -> register)
    std::unordered_map<std::string, ExprRegIndex> lexical;
    
    // Bytecode accumulator
    PatternBytecode bytecode;
    
    // Helper methods
    ExprRegIndex allocExprReg() { return nextExprReg++; }
    BoolRegIndex allocBoolReg() { return nextBoolReg++; }
    Label newLabel() { return nextLabel++; }
    
    void emit(Opcode op, const std::vector<Operand>& operands) {
        bytecode.addInstruction(Instruction{op, operands});
    }
    
    void bindLabel(Label L) {
        bytecode.addLabel(L);
    }
    
    void emitSuccessJumpIfTopLevel(Label successLabel, 
                                   bool isTopLevel) {
        if (isTopLevel) {
            emit(Opcode::JUMP, {OpLabel(successLabel)});
        }
    }
};
\end{lstlisting}

\subsection{Compilation Entry Point}

The main compilation function dispatches based on pattern type:

\begin{lstlisting}[style=cpp,caption={Main compilation dispatcher}]
static void compilePatternRec(CompilerState& st, 
                             std::shared_ptr<MExpr> mexpr,
                             Label successLabel,
                             Label failLabel,
                             bool isTopLevel) {
    // Dispatch based on expression type
    if (auto lit = dynamic_cast<MExprLiteral*>(mexpr.get())) {
        compileLiteral(st, lit, successLabel, failLabel, isTopLevel);
    }
    else if (auto sym = dynamic_cast<MExprSymbol*>(mexpr.get())) {
        compileSymbol(st, sym, successLabel, failLabel, isTopLevel);
    }
    else if (auto norm = dynamic_cast<MExprNormal*>(mexpr.get())) {
        auto head = norm->getHead();
        auto headSym = dynamic_cast<MExprSymbol*>(head.get());
        
        if (!headSym) {
            // Complex pattern like f[...][...]
            compileNormal(st, norm, successLabel, failLabel, isTopLevel);
            return;
        }
        
        std::string headName = headSym->getName();
        
        // Dispatch to specialized compilers
        if (headName == "Blank") {
            compileBlank(st, norm, successLabel, failLabel, isTopLevel);
        }
        else if (headName == "Pattern") {
            compilePattern(st, norm, successLabel, failLabel, isTopLevel);
        }
        else if (headName == "Alternatives") {
            compileAlternatives(st, norm, successLabel, 
                              failLabel, isTopLevel);
        }
        else if (headName == "PatternTest") {
            compilePatternTest(st, norm, successLabel, 
                             failLabel, isTopLevel);
        }
        else {
            // Structured pattern like List[a_, b_] or f[x_, y_]
            compileNormal(st, norm, successLabel, failLabel, isTopLevel);
        }
    }
}
\end{lstlisting}

\subsection{Compiling Literals}

Literals are the simplest pattern type:

\begin{lstlisting}[style=cpp,caption={Literal compilation}]
static void compileLiteral(CompilerState& st, 
                          MExprLiteral* mexprLit,
                          Label successLabel,
                          Label failLabel,
                          bool isTopLevel) {
    Expr literal = mexprLit->getExpr();
    
    // Emit MATCH_LITERAL instruction
    // If %e0 !== literal, jump to failLabel
    st.emit(Opcode::MATCH_LITERAL, {
        OpExprReg(0),           // Current value in %e0
        OpImm(literal),         // Literal to match
        OpLabel(failLabel)      // Jump here on mismatch
    });
    
    // If top-level, jump to success
    st.emitSuccessJumpIfTopLevel(successLabel, isTopLevel);
}
\end{lstlisting}

\textbf{Generated bytecode for} \texttt{5}:
\begin{lstlisting}[style=bytecode]
MATCH_LITERAL %e0, 5, L_fail
JUMP L_success  ; (if isTopLevel=true)
\end{lstlisting}

\subsection{Compiling Blanks}

Blanks (\texttt{\_}, \texttt{\_Integer}) match expressions with optional head constraints:

\begin{lstlisting}[style=cpp,caption={Blank compilation}]
static void compileBlank(CompilerState& st, 
                        std::shared_ptr<MExprNormal> mexprNormal,
                        Label successLabel,
                        Label failLabel,
                        bool isTopLevel) {
    // Blank[] has 0 or 1 arguments
    // Blank[]    -> match anything
    // Blank[h]   -> match expressions with head h
    
    if (mexprNormal->length() == 1) {
        auto headConstraint = mexprNormal->part(1);
        Expr headExpr = headConstraint->getExpr();
        
        // Emit MATCH_HEAD instruction
        st.emit(Opcode::MATCH_HEAD, {
            OpExprReg(0),
            OpImm(headExpr),
            OpLabel(failLabel)
        });
    }
    
    // If no head constraint, blank matches anything (no instructions)
    st.emitSuccessJumpIfTopLevel(successLabel, isTopLevel);
}
\end{lstlisting}

\textbf{Generated bytecode for} \texttt{\_Integer}:
\begin{lstlisting}[style=bytecode]
MATCH_HEAD %e0, Integer, L_fail
JUMP L_success
\end{lstlisting}

\subsection{Compiling Named Patterns}

Named patterns (\texttt{x\_}, \texttt{x\_Integer}) introduce variable bindings and require handling repeated occurrences:

\begin{lstlisting}[style=cpp,caption={Named pattern compilation}]
static void compilePattern(CompilerState& st, 
                          std::shared_ptr<MExprNormal> mexprNormal,
                          Label successLabel,
                          Label failLabel,
                          bool isTopLevel) {
    // Pattern[x, subpattern] structure
    auto varNameMExpr = mexprNormal->part(1);
    auto subpatternMExpr = mexprNormal->part(2);
    
    std::string varName = getPatternVariableName(varNameMExpr);
    
    // Check if this variable was already seen
    auto it = st.lexical.find(varName);
    if (it != st.lexical.end()) {
        // REPEATED VARIABLE: x already bound
        ExprRegIndex storedReg = it->second;
        
        // First compile the subpattern
        Label innerFail = st.newLabel();
        compilePatternRec(st, subpatternMExpr, successLabel, 
                         innerFail, false);
        
        // Then check equality with stored value
        BoolRegIndex b = st.allocBoolReg();
        st.emit(Opcode::SAMEQ, {
            OpBoolReg(b),
            OpExprReg(storedReg),  // Previously bound value
            OpExprReg(0)           // Current value
        });
        st.emit(Opcode::BRANCH_FALSE, {OpBoolReg(b), OpLabel(failLabel)});
        
        // Failure handler
        st.bindLabel(innerFail);
        st.emit(Opcode::JUMP, {OpLabel(failLabel)});
    }
    else {
        // FIRST OCCURRENCE: bind variable
        Label innerFail = st.newLabel();
        
        // Compile subpattern first
        compilePatternRec(st, subpatternMExpr, successLabel, 
                         innerFail, false);
        
        // Bind variable to current value
        ExprRegIndex bindReg = st.allocExprReg();
        st.emit(Opcode::MOVE, {OpExprReg(bindReg), OpExprReg(0)});
        
        // Record in lexical environment for later repetitions
        st.lexical[varName] = bindReg;
        
        st.emit(Opcode::BIND_VAR, {
            OpIdent(varName),
            OpExprReg(bindReg)
        });
        
        // Handle success
        Label afterFailHandler = st.newLabel();
        st.emit(Opcode::JUMP, {
            OpLabel(isTopLevel ? successLabel : afterFailHandler)
        });
        
        // Failure handler
        st.bindLabel(innerFail);
        st.emit(Opcode::JUMP, {OpLabel(failLabel)});
        
        st.bindLabel(afterFailHandler);
    }
}
\end{lstlisting}

\textbf{Generated bytecode for} \texttt{x\_Integer}:
\begin{lstlisting}[style=bytecode]
MATCH_HEAD %e0, Integer, L_inner_fail
MOVE %e1, %e0
BIND_VAR "Global`x", %e1
JUMP L_success

L_inner_fail:
JUMP L_fail
\end{lstlisting}

\subsection{Compiling Structured Patterns}

Structured patterns like \texttt{f[x\_, y\_]} or \texttt{\{a\_, b\_, c\_\}} require matching head, length, and each argument:

\begin{lstlisting}[style=cpp,caption={Structured pattern compilation},label=lst:compile_normal]
static void compileNormal(CompilerState& st, 
                         std::shared_ptr<MExprNormal> mexprNormal,
                         Label successLabel,
                         Label failLabel,
                         bool isTopLevel) {
    auto head = mexprNormal->getHead();
    size_t length = mexprNormal->length();
    
    // Check length
    st.emit(Opcode::MATCH_LENGTH, {
        OpExprReg(0),
        OpImmMint(length),
        OpLabel(failLabel)
    });
    
    // Check head
    Expr headExpr = head->getExpr();
    st.emit(Opcode::MATCH_HEAD, {
        OpExprReg(0),
        OpImm(headExpr),
        OpLabel(failLabel)
    });
    
    // Save the full expression for later restoration
    ExprRegIndex saveReg = st.allocExprReg();
    st.emit(Opcode::MOVE, {OpExprReg(saveReg), OpExprReg(0)});
    
    // Match each child pattern
    for (size_t i = 1; i <= length; ++i) {
        auto childPattern = mexprNormal->part(i);
        
        // Extract part i
        ExprRegIndex partReg = st.allocExprReg();
        st.emit(Opcode::GET_PART, {
            OpExprReg(partReg),
            OpExprReg(0),
            OpImmMint(i)
        });
        
        // Make part the current value
        st.emit(Opcode::MOVE, {OpExprReg(0), OpExprReg(partReg)});
        
        // Compile child pattern (not top-level)
        Label innerFail = st.newLabel();
        compilePatternRec(st, childPattern, successLabel, 
                         innerFail, false);
        
        // Restore full expression for next iteration
        st.emit(Opcode::MOVE, {OpExprReg(0), OpExprReg(saveReg)});
        
        // Inner failure handler
        st.bindLabel(innerFail);
        st.emit(Opcode::JUMP, {OpLabel(failLabel)});
    }
    
    // All parts matched successfully
    st.emitSuccessJumpIfTopLevel(successLabel, isTopLevel);
}
\end{lstlisting}

\textbf{Generated bytecode for} \texttt{f[x\_, y\_]}:
\begin{lstlisting}[style=bytecode]
MATCH_LENGTH %e0, 2, L_fail
MATCH_HEAD %e0, f, L_fail
MOVE %e1, %e0

; Match first argument (x_)
GET_PART %e2, %e0, 1
MOVE %e0, %e2
MOVE %e3, %e0
BIND_VAR "Global`x", %e3
MOVE %e0, %e1       ; Restore

; Match second argument (y_)
GET_PART %e4, %e0, 2
MOVE %e0, %e4
MOVE %e5, %e0
BIND_VAR "Global`y", %e5

JUMP L_success
\end{lstlisting}

\subsection{Compiling Alternatives}

Alternatives (\texttt{p1 | p2 | p3}) use the TRY/RETRY/TRUST protocol:

\begin{lstlisting}[style=cpp,caption={Alternative compilation},label=lst:compile_alternatives]
static void compileAlternatives(CompilerState& st, 
                               std::shared_ptr<MExprNormal> mexpr,
                               Label successLabel,
                               Label failLabel,
                               bool isTopLevel) {
    size_t numAlts = mexpr->length();
    
    // Save lexical environment (restore for each alternative)
    auto savedLexical = st.lexical;
    
    // Generate labels for each alternative
    std::vector<Label> altLabels;
    for (size_t i = 0; i < numAlts; ++i) {
        altLabels.push_back(st.newLabel());
    }
    
    // Local success label (all alternatives jump here on success)
    Label localSuccess = st.newLabel();
    
    // FIRST ALTERNATIVE
    st.emit(Opcode::TRY, {OpLabel(altLabels[1])});
    st.bindLabel(altLabels[0]);
    {
        auto firstAlt = mexpr->part(1);
        Label firstFail = st.newLabel();
        
        compilePatternRec(st, firstAlt, localSuccess, firstFail, true);
        
        st.bindLabel(firstFail);
        st.emit(Opcode::FAIL, {});
    }
    
    // MIDDLE ALTERNATIVES (if any)
    for (size_t i = 1; i < numAlts - 1; ++i) {
        st.lexical = savedLexical;  // Restore lexical environment
        
        st.bindLabel(altLabels[i]);
        st.emit(Opcode::RETRY, {OpLabel(altLabels[i + 1])});
        
        auto alt = mexpr->part(i + 1);
        Label altFail = st.newLabel();
        
        compilePatternRec(st, alt, localSuccess, altFail, true);
        
        st.bindLabel(altFail);
        st.emit(Opcode::FAIL, {});
    }
    
    // LAST ALTERNATIVE
    st.lexical = savedLexical;
    st.bindLabel(altLabels[numAlts - 1]);
    st.emit(Opcode::TRUST, {});
    {
        auto lastAlt = mexpr->part(numAlts);
        compilePatternRec(st, lastAlt, localSuccess, failLabel, true);
    }
    
    // Local success handler
    st.bindLabel(localSuccess);
    st.emitSuccessJumpIfTopLevel(successLabel, isTopLevel);
}
\end{lstlisting}

\textbf{Generated bytecode for} \texttt{\_Real | \_Integer}:
\begin{lstlisting}[style=bytecode]
TRY L_alt2

L_alt1:
MATCH_HEAD %e0, Real, L_fail1
JUMP L_local_success

L_fail1:
FAIL

L_alt2:
TRUST
MATCH_HEAD %e0, Integer, L_fail
JUMP L_local_success

L_local_success:
JUMP L_success  ; (if isTopLevel)
\end{lstlisting}

\subsection{Compiling Pattern Tests}

Pattern tests (\texttt{\_?test}) apply a test function and jump on failure:

\begin{lstlisting}[style=cpp,caption={Pattern test compilation}]
static void compilePatternTest(CompilerState& st, 
                              std::shared_ptr<MExprNormal> mexprNormal,
                              Label successLabel,
                              Label failLabel,
                              bool isTopLevel) {
    // PatternTest[patt, test]
    auto pvalMExpr = mexprNormal->part(1);
    auto testMExpr = mexprNormal->part(2);
    
    // Compile base pattern FIRST (not test!)
    compilePatternRec(st, pvalMExpr, successLabel, failLabel, false);
    
    // THEN apply test to matched value
    st.emit(Opcode::APPLY_TEST, {
        OpExprReg(0),
        OpImm(testMExpr->getExpr()),
        OpLabel(failLabel)
    });
    
    st.emitSuccessJumpIfTopLevel(successLabel, isTopLevel);
}
\end{lstlisting}

\textbf{Generated bytecode for} \texttt{\_Integer?EvenQ}:
\begin{lstlisting}[style=bytecode]
MATCH_HEAD %e0, Integer, L_fail
APPLY_TEST %e0, EvenQ, L_fail
JUMP L_success
\end{lstlisting}

% ----------------------------------------------------------------------------
\section{Virtual Machine}
\label{sec:vm_implementation}

\subsection{VM State Structure}

The virtual machine maintains execution state in a single structure:

\begin{lstlisting}[style=cpp,caption={VirtualMachine state}]
class VirtualMachine {
private:
    // Bytecode and execution
    std::shared_ptr<PatternBytecode> bytecode;
    size_t pc;  // Program counter
    size_t cyclesExecuted;
    
    // Registers
    std::vector<Expr> exprRegs;
    std::vector<bool> boolRegs;
    
    // Scoping
    std::vector<Frame> frames;
    Frame resultFrame;
    
    // Backtracking
    std::vector<ChoicePoint> choiceStack;
    std::vector<TrailEntry> trail;
    
public:
    void initialize(const std::shared_ptr<PatternBytecode>& bc);
    bool match(const Expr& input);
    const Frame& getResultBindings() const { return resultFrame; }
    size_t getCyclesExecuted() const { return cyclesExecuted; }
};
\end{lstlisting}

\subsection{Main Execution Loop}

The execution loop is a classic fetch-decode-execute cycle:

\begin{lstlisting}[style=cpp,caption={VM execution loop}]
bool VirtualMachine::match(const Expr& input) {
    // Initialize
    pc = 0;
    cyclesExecuted = 0;
    exprRegs[0] = input;  // Current value in %e0
    
    frames.clear();
    frames.emplace_back();  // Root frame
    
    choiceStack.clear();
    trail.clear();
    
    // Execute until HALT
    while (pc < bytecode->instructions.size()) {
        const Instruction& instr = bytecode->instructions[pc];
        ++cyclesExecuted;
        
        // Dispatch to instruction handler
        switch (instr.opcode) {
            case Opcode::MOVE:
                execute_MOVE(instr);
                break;
            case Opcode::LOAD_IMM:
                execute_LOAD_IMM(instr);
                break;
            case Opcode::GET_PART:
                execute_GET_PART(instr);
                break;
            case Opcode::MATCH_HEAD:
                execute_MATCH_HEAD(instr);
                break;
            case Opcode::MATCH_LENGTH:
                execute_MATCH_LENGTH(instr);
                break;
            case Opcode::MATCH_LITERAL:
                execute_MATCH_LITERAL(instr);
                break;
            case Opcode::APPLY_TEST:
                execute_APPLY_TEST(instr);
                break;
            case Opcode::SAMEQ:
                execute_SAMEQ(instr);
                break;
            case Opcode::BIND_VAR:
                execute_BIND_VAR(instr);
                break;
            case Opcode::JUMP:
                execute_JUMP(instr);
                break;
            case Opcode::BRANCH_FALSE:
                execute_BRANCH_FALSE(instr);
                break;
            case Opcode::BEGIN_BLOCK:
                execute_BEGIN_BLOCK(instr);
                break;
            case Opcode::END_BLOCK:
                execute_END_BLOCK(instr);
                break;
            case Opcode::EXPORT_BINDINGS:
                execute_EXPORT_BINDINGS(instr);
                break;
            case Opcode::TRY:
                execute_TRY(instr);
                break;
            case Opcode::RETRY:
                execute_RETRY(instr);
                break;
            case Opcode::TRUST:
                execute_TRUST(instr);
                break;
            case Opcode::FAIL:
                execute_FAIL(instr);
                break;
            case Opcode::HALT:
                return boolRegs[0];  // Return result in %b0
            default:
                throw std::runtime_error("Unknown opcode");
        }
        
        ++pc;  // Advance (unless jump occurred)
    }
    
    return false;  // Should not reach here
}
\end{lstlisting}

\subsection{Instruction Implementations}

\subsubsection{Data Movement Instructions}

\begin{lstlisting}[style=cpp,caption={MOVE and LOAD\_IMM}]
void VirtualMachine::execute_MOVE(const Instruction& instr) {
    auto dst = std::get<ExprRegOp>(instr.ops[0]);
    auto src = std::get<ExprRegOp>(instr.ops[1]);
    exprRegs[dst.v] = exprRegs[src.v];
}

void VirtualMachine::execute_LOAD_IMM(const Instruction& instr) {
    if (instr.ops[0].index() == OpBoolReg_idx) {
        auto dst = std::get<BoolRegOp>(instr.ops[0]);
        auto val = std::get<ImmMint>(instr.ops[1]);
        boolRegs[dst.v] = (val != 0);
    }
    else {
        auto dst = std::get<ExprRegOp>(instr.ops[0]);
        auto val = std::get<ImmExpr>(instr.ops[1]);
        exprRegs[dst.v] = val;
    }
}
\end{lstlisting}

\subsubsection{Pattern Matching Instructions}

\begin{lstlisting}[style=cpp,caption={MATCH\_HEAD, MATCH\_LENGTH, MATCH\_LITERAL}]
void VirtualMachine::execute_MATCH_HEAD(const Instruction& instr) {
    auto src = std::get<ExprRegOp>(instr.ops[0]);
    auto expectedHead = std::get<ImmExpr>(instr.ops[1]);
    auto failLabel = std::get<LabelOp>(instr.ops[2]);
    
    Expr actualHead = exprRegs[src.v].head();
    
    if (!actualHead.sameQ(expectedHead)) {
        jump(failLabel, true);  // Jump and decrement PC
    }
}

void VirtualMachine::execute_MATCH_LENGTH(const Instruction& instr) {
    auto src = std::get<ExprRegOp>(instr.ops[0]);
    auto expectedLen = std::get<ImmMint>(instr.ops[1]);
    auto failLabel = std::get<LabelOp>(instr.ops[2]);
    
    mint actualLen = exprRegs[src.v].length();
    
    if (actualLen != expectedLen) {
        jump(failLabel, true);
    }
}

void VirtualMachine::execute_MATCH_LITERAL(const Instruction& instr) {
    auto src = std::get<ExprRegOp>(instr.ops[0]);
    auto literal = std::get<ImmExpr>(instr.ops[1]);
    auto failLabel = std::get<LabelOp>(instr.ops[2]);
    
    if (!exprRegs[src.v].sameQ(literal)) {
        jump(failLabel, true);
    }
}

void VirtualMachine::execute_APPLY_TEST(const Instruction& instr) {
    auto src = std::get<ExprRegOp>(instr.ops[0]);
    auto testFunc = std::get<ImmExpr>(instr.ops[1]);
    auto failLabel = std::get<LabelOp>(instr.ops[2]);
    
    // Construct testFunc[value] and evaluate
    Expr testRes = Expr::construct(testFunc, exprRegs[src.v]).eval();
    Expr trueExpr = Expr::ToExpression("True");
    
    // Only explicit True is success
    if (!testRes.sameQ(trueExpr)) {
        jump(failLabel, true);
    }
}
\end{lstlisting}

\subsubsection{Backtracking Instructions}

\begin{lstlisting}[style=cpp,caption={TRY, RETRY, TRUST, FAIL}]
void VirtualMachine::execute_TRY(const Instruction& instr) {
    auto nextAlt = std::get<LabelOp>(instr.ops[0]);
    
    ChoicePoint cp;
    cp.returnPC = pc;
    cp.nextAlternative = nextAlt.v;
    cp.savedExprRegs = exprRegs;
    cp.savedBoolRegs = boolRegs;
    cp.trailMark = trail.size();
    cp.frameMark = frames.size();
    
    choiceStack.push_back(cp);
}

void VirtualMachine::execute_RETRY(const Instruction& instr) {
    auto nextAlt = std::get<LabelOp>(instr.ops[0]);
    
    if (!choiceStack.empty()) {
        choiceStack.back().nextAlternative = nextAlt.v;
    }
}

void VirtualMachine::execute_TRUST(const Instruction& instr) {
    if (!choiceStack.empty()) {
        choiceStack.pop_back();
    }
}

void VirtualMachine::execute_FAIL(const Instruction& instr) {
    if (!backtrack()) {
        // No more choice points: permanent failure
        boolRegs[0] = false;
        pc = bytecode->instructions.size();  // Jump to end
    }
}

bool VirtualMachine::backtrack() {
    if (choiceStack.empty()) {
        return false;  // No choice points
    }
    
    auto& cp = choiceStack.back();
    
    // Restore registers
    exprRegs = cp.savedExprRegs;
    boolRegs = cp.savedBoolRegs;
    
    // Restore frames
    while (frames.size() > cp.frameMark) {
        frames.pop_back();
    }
    
    // Undo bindings
    unwindTrail(cp.trailMark);
    
    // Jump to next alternative
    pc = bytecode->resolveLabel(cp.nextAlternative).value() - 1;
    // (-1 because pc++ happens after instruction)
    
    return true;
}

void VirtualMachine::unwindTrail(size_t mark) {
    while (trail.size() > mark) {
        const TrailEntry& entry = trail.back();
        frames[entry.frameIndex].unbindVariable(entry.varName);
        trail.pop_back();
    }
}
\end{lstlisting}

\subsubsection{Binding and Scope Instructions}

\begin{lstlisting}[style=cpp,caption={BIND\_VAR, BEGIN\_BLOCK, END\_BLOCK}]
void VirtualMachine::execute_BIND_VAR(const Instruction& instr) {
    auto varName = std::get<Ident>(instr.ops[0]);
    auto src = std::get<ExprRegOp>(instr.ops[1]);
    
    auto& currentFrame = frames.back();
    
    // Trail if choice points exist
    if (!choiceStack.empty() && currentFrame.hasVariable(varName)) {
        trail.emplace_back(varName, frames.size() - 1);
    }
    
    currentFrame.bindVariable(varName, exprRegs[src.v]);
}

void VirtualMachine::execute_BEGIN_BLOCK(const Instruction& instr) {
    frames.emplace_back();  // Create new scope
}

void VirtualMachine::execute_END_BLOCK(const Instruction& instr) {
    if (frames.size() > 1) {
        // Merge bindings to parent frame
        auto bindings = frames.back().getBindings();
        frames.pop_back();
        
        for (const auto& [name, value] : bindings) {
            frames.back().bindVariable(name, value);
        }
    }
}

void VirtualMachine::execute_EXPORT_BINDINGS(const Instruction& instr) {
    // Copy all bindings to result frame
    resultFrame.clear();
    for (const auto& frame : frames) {
        for (const auto& [name, value] : frame.getBindings()) {
            resultFrame.bindVariable(name, value);
        }
    }
}
\end{lstlisting}

\subsection{Helper Functions}

\begin{lstlisting}[style=cpp,caption={Jump and label resolution}]
void VirtualMachine::jump(LabelOp label, bool decrementPC) {
    auto targetOpt = bytecode->resolveLabel(label.v);
    if (!targetOpt) {
        throw std::runtime_error("Unresolved label");
    }
    
    pc = targetOpt.value();
    if (decrementPC) {
        --pc;  // Compensate for pc++ in main loop
    }
}
\end{lstlisting}

% ----------------------------------------------------------------------------
\section{Integration with Wolfram Language}
\label{sec:librarylink}

\subsection{LibraryLink Interface}

The C++ VM is exposed to Wolfram Language through LibraryLink functions:

\begin{lstlisting}[style=cpp,caption={LibraryLink function registration}]
EXTERN_C DLLEXPORT int WolframLibrary_initialize(WolframLibraryData libData) {
    // Register managed object types
    registerObjectFactory<VirtualMachine>("VirtualMachine");
    registerObjectFactory<PatternBytecode>("PatternBytecode");
    return LIBRARY_NO_ERROR;
}

EXTERN_C DLLEXPORT mint WolframLibrary_compile(
    WolframLibraryData libData, mint argc, MArgument* args, MArgument res) {
    
    // Extract pattern expression
    MTensor patternTensor = MArgument_getMTensor(args[0]);
    Expr patternExpr = /* convert from tensor */;
    
    // Convert to MExpr
    auto mexpr = MExpr::fromExpr(patternExpr);
    
    // Compile to bytecode
    auto bytecode = CompilePatternToBytecode(mexpr);
    
    // Return managed object
    MArgument_setManagedLibraryExpressionID(res, 
        createManagedObject(bytecode, "PatternBytecode"));
    
    return LIBRARY_NO_ERROR;
}

EXTERN_C DLLEXPORT mint WolframLibrary_execute(
    WolframLibraryData libData, mint argc, MArgument* args, MArgument res) {
    
    // Get VM and bytecode objects
    auto vm = getManagedObject<VirtualMachine>(
        MArgument_getManagedLibraryExpressionID(args[0]));
    auto bytecode = getManagedObject<PatternBytecode>(
        MArgument_getManagedLibraryExpressionID(args[1]));
    Expr input = /* extract from args[2] */;
    
    // Initialize and execute
    vm->initialize(bytecode);
    bool result = vm->match(input);
    
    // Return result as Association
    Expr resultAssoc = Expr::ToExpression("Association")[
        Expr::ToExpression("Rule")[
            Expr::ToExpression("Result"), 
            Expr::ToExpression(result ? "True" : "False")
        ],
        Expr::ToExpression("Rule")[
            Expr::ToExpression("CyclesExecuted"),
            Expr::ToExpression(vm->getCyclesExecuted())
        ],
        // ... bindings ...
    ];
    
    MArgument_setMTensor(res, /* convert resultAssoc to tensor */);
    return LIBRARY_NO_ERROR;
}
\end{lstlisting}

\subsection{Wolfram Language Wrapper}

The Wolfram Language interface provides a high-level API:

\begin{lstlisting}[caption={PatternMatcherExecute implementation}]
PatternMatcherExecute[pattern_, expr_] := Module[
    {vm, bytecode, result},
    
    (* Create VM instance *)
    vm = CreatePatternMatcherVirtualMachine[];
    
    (* Compile pattern to bytecode *)
    bytecode = CompilePatternToBytecode[pattern];
    
    (* Execute match *)
    result = vm["match", bytecode, expr];
    
    (* Clean up *)
    vm["shutdown"];
    
    result
];
\end{lstlisting}

% ----------------------------------------------------------------------------
\section{Implementation Summary}
\label{sec:impl_summary}

\subsection{Code Statistics}

\begin{table}[ht]
\centering
\begin{tabular}{lrr}
\toprule
\textbf{Component} & \textbf{Files} & \textbf{Lines of Code} \\
\midrule
AST Layer & 7 & 400 \\
VM Core (Compiler) & 2 & 800 \\
VM Core (Execution) & 2 & 600 \\
Opcode Definitions & 2 & 600 \\
Bytecode Representation & 2 & 300 \\
LibraryLink Integration & 1 & 200 \\
Expr Wrapper & 2 & 350 \\
\midrule
\textbf{C++ Total} & \textbf{18} & \textbf{3,250} \\
\midrule
Wolfram Interface & 8 & 650 \\
\midrule
\textbf{Grand Total} & \textbf{26} & \textbf{3,900} \\
\bottomrule
\end{tabular}
\caption{Code statistics by component}
\label{tab:code_stats}
\end{table}

\subsection{Key Implementation Decisions}

\begin{enumerate}
    \item \textbf{Register-based over stack-based}: Reduces instruction count and makes control flow more explicit
    
    \item \textbf{Separate MExpr representation}: Allows efficient C++ manipulation without LibraryLink overhead
    
    \item \textbf{Lexical environment in compiler}: Detects repeated variables at compile-time rather than runtime
    
    \item \textbf{TRY/RETRY/TRUST protocol}: Provides structured backtracking with clear choice point lifecycle
    
    \item \textbf{Trail optimization}: Only trails bindings when choice points exist
    
    \item \textbf{Fused match operations}: Combines test and conditional jump in single instruction
    
    \item \textbf{Smart pointer usage}: Manages MExpr lifetimes automatically
    
    \item \textbf{Template-based operand handling}: Uses \texttt{std::variant} for type-safe operands
\end{enumerate}

\subsection{Testing Infrastructure}

The implementation includes comprehensive testing:

\begin{itemize}
    \item \textbf{Unit tests}: Individual instruction execution
    \item \textbf{Integration tests}: Full compilation + execution pipeline
    \item \textbf{Equivalence tests}: Comparison with native \texttt{MatchQ}
    \item \textbf{Edge cases}: Empty patterns, deep nesting, complex alternatives
\end{itemize}

Test organization:
\begin{itemize}
    \item \texttt{tests/AST/}: MExpr conversion and manipulation
    \item \texttt{tests/PatternMatcher/FrontEnd.mt}: Compilation tests
    \item \texttt{tests/PatternMatcher/BackEnd.mt}: VM execution tests
    \item \texttt{tests/PatternMatcher/PatternMatcherExecute.mt}: End-to-end tests
\end{itemize}

% ============================================================================
% CHAPTER 5: EVALUATION (outline - to be expanded)
% ============================================================================
\chapter{Evaluation}
\label{chap:evaluation}

% TODO: Expand this chapter with actual measurements
% Focus on INTRINSIC metrics, not comparative benchmarks

\section{Correctness Validation}

\subsection{Test Suite Overview}

\subsection{Equivalence with Native MatchQ}

\section{Bytecode Characteristics}

\subsection{Instruction Count Analysis}

\subsection{Register Usage Patterns}

\subsection{Code Density Metrics}

\section{Execution Metrics}

\subsection{Cycle Counts}

\subsection{Backtracking Events}

\subsection{Memory Footprint}

\section{Analysis and Discussion}

% ============================================================================
% CHAPTER 6: CONCLUSIONS (outline - to be expanded)
% ============================================================================
\chapter{Conclusions and Future Work}
\label{chap:conclusions}

\section{Summary of Contributions}

\section{Limitations}

\section{Future Work}

% ============================================================================
% BACK MATTER
% ============================================================================
\backmatter

\begin{thebibliography}{99}

\bibitem{ait-kaci1999}
Hassan Aït-Kaci.
\textit{Warren's Abstract Machine: A Tutorial Reconstruction}.
MIT Press, 1999.

\bibitem{ierusalimschy2005}
Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes.
\textit{The Implementation of Lua 5.0}.
Journal of Universal Computer Science, vol. 11, no. 7, 2005.

\bibitem{maranget2008}
Luc Maranget.
\textit{Compiling Pattern Matching to Good Decision Trees}.
ML Workshop, 2008.

\bibitem{wolfram2015}
Stephen Wolfram.
\textit{An Elementary Introduction to the Wolfram Language}.
Wolfram Media, 2015.

% TODO: Add more references

\end{thebibliography}

\end{document}
