# Reporte
**Fecha:** 14 de noviembre de 2025 
**Project:** Una mÃ¡quina virtual para el *pattern matcher* de *Wolfram Language*  
**Autor:** HÃ©ctor Daniel Sanchez DomÃ­nguez  
**Asesor:** HÃ©ctor AndrÃ©s Melgar Sasieta  
**Estado:** Fase 2B

---

## ResÃºmen Ejecutivo

Este reporte documenta la implementaciÃ³n de una **mÃ¡quina virtual basada en registros para *pattern matching*** en Wolfram Language. El proyecto ha transitado desde la investigaciÃ³n y diseÃ±o inicial (Fase 1) a travÃ©s de un prototipo completo basado en pila (Fase 2) hasta la implementaciÃ³n actual de bajo nivel en C++ con soporte completo de *backtracking* (Fase 2B).

**Logro Principal:** Hemos implementado una **VM de *pattern matching* lista para producciÃ³n** que compila y ejecuta exitosamente patrones de Wolfram Language con:
- **Patrones anidados** con alcance (*scoping*) apropiado
- **Variables repetidas** (`f[x_, x_]`) con seguimiento lÃ©xico en tiempo de compilaciÃ³n
- **Alternativas** (`p1 | p2 | p3`) usando *backtracking* estilo WAM
- **~20 instrucciones de *bytecode*** ejecutÃ¡ndose en una arquitectura basada en registros
- **Equivalencia semÃ¡ntica completa** con `MatchQ` nativo para tipos de patrones soportados

---

## Tabla de Contenidos

1. Resumen del Proyecto
2. Resumen de la Arquitectura
3. Componentes Principales: CompilaciÃ³n y EjecuciÃ³n
4. Aspectos Destacados de la ImplementaciÃ³n
5. Capacidades Actuales
6. Ejemplos (pendiente)
7. Consideraciones de Rendimiento (pendiente)
8. PrÃ³ximos Pasos (pendiente)
9. ConclusiÃ³n (pendiente)

---

## 1. Resumen del Proyecto

### 1.1 MotivaciÃ³n

El *pattern matching* de Wolfram Language es poderoso pero puede ser poco eficiente al trabajar con patrones complejos. Este proyecto implementa una **VM de *pattern matching* compilado** que:

- **Compila patrones a *bytecode*** una vez, ejecuta muchas veces (amortiza el costo de compilaciÃ³n)
- **Usa arquitectura basada en registros** (mÃ¡s rÃ¡pida que manipulaciÃ³n de pila)
- **Implementa *backtracking* estructurado** (*choice points* estilo WAM, no *ad-hoc*)
- **Provee mÃ©tricas observables** (ciclos, memoria, tamaÃ±o de *bytecode*)
- **Mantiene correctitud** (equivalencia semÃ¡ntica con `MatchQ` nativo)

### 1.2 Progreso de la LÃ­nea de Tiempo

De acuerdo al cronograma:

âœ… **Fase 1 (Mar-May 2025):** InvestigaciÃ³n y DiseÃ±o - **COMPLETADA**
- RevisiÃ³n de literatura, diseÃ±o arquitectÃ³nico, definiciÃ³n de ISA
- Entregable: Reporte TÃ©cnico #2

âœ… **Fase 2 (May-Jul 2025):** ImplementaciÃ³n de VM basada en Pila - **COMPLETADA**
- *Front-end* (patrÃ³n â†’ IR), compilador de *bytecode*, motor de ejecuciÃ³n
- Entregable: Prototipo Funcional de VM basada en Pila

âœ… **Fase 2A (Ago-Nov 2025):** ImplementaciÃ³n de Bajo Nivel en C++ - **COMPLETADA**
- *Runtime* en C++, ejecuciÃ³n basada en registros, soporte de *backtracking*
- Entregable: LibrerÃ­a de C++ con herramientas de depuraciÃ³n

ğŸ”„ **Fase 2B (Nov 2025):** Expandir Cobertura de Patrones - **EN PROGRESO**
- Implementar `PatternTest` (`_?test`)
- Implementar `x__`, `x___`, `x..`, `x...`
- Expandir suite de pruebas
- Actualizar documentaciÃ³n del Wolfram *paclet*
- **QuÃ© sigue:** DocumentaciÃ³n formal de completitud de caracterÃ­sticas

â³ **Fase 3 (Dic 2025):** OptimizaciÃ³n y ValidaciÃ³n - **PRÃ“XIMA**
- Optimizaciones de IR, suite de pruebas comprehensiva, *benchmarking*

ğŸ”„ **Fase 4 (Nov 2025 - Ene 2026):** DocumentaciÃ³n y Escritura de Tesis - **EN PROGRESO**
- Borrador de tesis en progreso
- Objetivo de completaciÃ³n: Enero 2026

### 1.3 Recursos del Proyecto

- **CÃ³digo Fuente:** [github.com/daneelsan/WolframLanguagePatternMatcher](https://github.com/daneelsan/WolframLanguagePatternMatcher/)

- **Paclet de Wolfram Language:** [wolframcloud.com/obj/daniels/DeployedResources/Paclet/DanielS/PatternMatcherVM/](https://www.wolframcloud.com/obj/daniels/DeployedResources/Paclet/DanielS/PatternMatcherVM/)

### 1.4 Ejemplo "Quickstart"

AquÃ­ hay un ejemplo completo mostrando la VM en acciÃ³n:

```wolfram
(* Load the paclet *)
PacletInstall["DanielS/PatternMatcherVM"]
Needs["DanielS`PatternMatcherVM`"]

(* Simple pattern match *)
In[]:= PatternMatcherExecute[{x_, x_}, {5, 5}]
Out[]= <|
  "Result" -> True, 
  "CyclesExecuted" -> 22, 
  "Bindings" -> <|"Global`x" -> 5|>
|>

(* Alternative pattern with backtracking *)
In[]:= PatternMatcherExecute[_Integer | _Real, 5]
Out[]= <|
  "Result" -> True, 
  "CyclesExecuted" -> 8, 
  "Bindings" -> <||>
|>

(* Pattern that fails *)
In[]:= PatternMatcherExecute[{x_, x_}, {5, 10}]
Out[]= <|
  "Result" -> False, 
  "CyclesExecuted" -> 17, 
  "Bindings" -> <||>
|>
```

**CÃ³mo funciona:** La VM compila el patrÃ³n una vez, lo ejecuta contra la entrada, y retorna si coincidiÃ³ junto con cualquier *binding* de variables.

**Internamente...**
1. **CompilaciÃ³n:** PatrÃ³n â†’ AST â†’ *Bytecode* (~10-20 instrucciones)
2. **EjecuciÃ³n:** La VM ejecuta *bytecode* contra la entrada (~5-30 ciclos)
3. **Resultado:** Resultado booleano de coincidencia + *bindings* de variables (si hay alguno)

El *overhead* de compilaciÃ³n se amortiza sobre coincidencias repetidas.

---

## 2. Resumen de la Arquitectura

### 2.1 *Pipeline* de CompilaciÃ³n

El sistema sigue un **enfoque de compilaciÃ³n multi-etapa**:

```
ExpresiÃ³n de PatrÃ³n (Wolfram Language)
         â†“
    [Parser/AST]
         â†“
  MExpr (AST Interno)
         â†“
 [Compilador de Patrones]
         â†“
Instrucciones de Bytecode
         â†“
[MÃ¡quina Virtual]
         â†“
  Result de Concidencia + Bindings
```

### 2.2 Architecture de la MÃ¡quina Virtual

La VM estÃ¡ **basada en registros** (no en pila), tomando ideas de:
- **Warren Abstract Machine (WAM):** Choice points and backtracking de Prolog
- **Lua VM:** Modelo de ejecuciÃ³n basado en registros
- **DiseÃ±o estÃ¡ndar de VM:** *Opcodes* explÃ­citos, flujo de control basado en *labels*

Inicialmente, intentamos un enfoque basado en pila, pero cambiamos a registros despuÃ©s de que la literatura revelÃ³ las ventajas de los VM basados en registros. 

**Decisiones arquitectÃ³nicas clave:**

1. **Modelo de Registros:**
   - Registros de expresiones (`%e0`, `%e1`, `%e2`, ...) para valores `Expr`
   - Registros booleanos (`%b0`, `%b1`, `%b2`, ...) para resultados de comparaciÃ³n
   - ConvenciÃ³n: `%e0` = valor actual siendo coincidido, `%b0` = resultado final

2. **Frame Stack:**
   - *Lexical Scoping* vÃ­a `BEGIN_BLOCK`/`END_BLOCK`
   - Cada *frame* contiene *bindings* de variables (`x â†’ valor`)
   - *Frames* anidados para patrones anidados (`f[g[x_]]`)

3. **Choice Point Stack:**
   - ElecciÃ³n no-determinÃ­stica para alternativas (`p1 | p2 | p3`)
   - *Saves state*: registros, *frames*, posiciÃ³n del *trail*
   - El *backtracking* restaura estado e intenta la siguiente alternativa

4. **Trail (Registro de Deshacer):**
   - Registra *bindings* de variables para reversiÃ³n en *backtrack*
   - Solo activo cuando existen choice points (optimizaciÃ³n)
   - Habilita alternativas independientes en `x_Integer | x_Real`

### 2.3 Arquitectura del Conjunto de Instrucciones (ISA)

La VM implementa *20 opcodes cuidadosamente diseÃ±ados* organizados en categorÃ­as:

| CategorÃ­a | Opcodes | PropÃ³sito |
|----------|---------|---------|
| **Movimiento de Datos** (2) | `MOVE`, `LOAD_IMM` | Mover valores entre registros y cargar constantes |
| **IntrospecciÃ³n** (1) | `GET_PART` | Extraer partes de expresiones (`f[a,b] â†’ a`) |
| **Pattern Matching** (3) | `MATCH_HEAD`, `MATCH_LENGTH`, `MATCH_LITERAL` | Probar restricciones de patrÃ³n, saltar en fallo |
| **ComparaciÃ³n** (1) | `SAMEQ` | Probar igualdad estructural (para `f[x_, x_]`) |
| **Binding** (1) | `BIND_VAR` | Vincular variables de patrÃ³n (`x â†’ value`) |
| **Flujo de Control** (3) | `JUMP`, `BRANCH_FALSE`, `HALT` | Saltos incondicionales/condicionales, detener ejecuciÃ³n |
| **Scope Management** (3) | `BEGIN_BLOCK`, `END_BLOCK`, `EXPORT_BINDINGS` | Gestionar alcance de variables |
| **Backtracking** (5) | `TRY`, `RETRY`, `TRUST`, `CUT`, `FAIL` | Crear/gestionar *choice points* para alternativas |
| **DepuraciÃ³n** (1) | `DEBUG_PRINT` | Trazar ejecuciÃ³n |

**Principios de diseÃ±o:**
- **Ortogonalidad:** Cada instrucciÃ³n hace una cosa bien
- **Operaciones fusionadas:** `MATCH_HEAD` combina prueba + salto condicional para eficiencia
- **Control explÃ­cito:** Las operaciones de *backtracking* son explÃ­citas (`TRY`/`RETRY`/`TRUST`/`FAIL`)
- **Conjunto mÃ­nimo:** Solo 20 *opcodes*

Los prototipos tempranos usaban 30+ *opcodes* antes de que nos diÃ©ramos cuenta de que muchos podÃ­an fusionarse.

### 2.4 Diagrama de Arquitectura

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Wolfram Language Layer                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ PatternMatcher   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  CompilePattern         â”‚   â”‚
â”‚  â”‚ Execute          â”‚         â”‚  ToBytecode             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚ LibraryLink
                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        C++ Layer                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   MExpr      â”‚â”€â”€â”€â–¶â”‚   Compiler   â”‚â”€â”€â–¶â”‚ PatternByte-  â”‚   â”‚
â”‚  â”‚   (AST)      â”‚    â”‚   State      â”‚   â”‚ code          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                 â”‚           â”‚
â”‚                                                 â–¼           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚            VirtualMachine                            â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚  Registers â”‚  â”‚ Frame Stack â”‚  â”‚ Choice Stack â”‚   â”‚   â”‚
â”‚  â”‚  â”‚ %e0, %e1.. â”‚  â”‚             â”‚  â”‚              â”‚   â”‚   â”‚
â”‚  â”‚  â”‚ %b0, %b1.. â”‚  â”‚  Bindings   â”‚  â”‚ Backtracking â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚                                                      â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚   â”‚
â”‚  â”‚  â”‚   Trail    â”‚  â”‚ Result Frameâ”‚                     â”‚   â”‚
â”‚  â”‚  â”‚ (Undo Log) â”‚  â”‚             â”‚                     â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. Componentes Principales: CompilaciÃ³n y EjecuciÃ³n

**Arquitectura del Compilador:**

El compilador estÃ¡ estructurado alrededor de `CompilerState`, que rastrea:
- **Registros:** De expresiones (`%e0`, `%e1`, ...) y boleanos (`%b0`, `%b1`, ...)
- **Etiquetas:** De entrada, Ã©xito, fallo, etiquetas de alternativas
- **Entorno LÃ©xico:** Mapeo de nombres de variables a Ã­ndices de registros
- ***Buffer* de *Bytecode*:** Instrucciones acumuladas

**La compilaciÃ³n es recursiva**: Cada tipo de patrÃ³n tiene una funciÃ³n de compilaciÃ³n especializada que emite *bytecode* y actualiza el estado del compilador.

### 3.1 *Front-End*: CompilaciÃ³n de Patrones

**File:** CompilePatternToBytecode.cpp

El compilador traduce expresiones de patrones a *bytecode*:

**Input:** ExpresiÃ³n de patrÃ³n (e.g., `f[x_Integer, x_]`)  
**Output:** `PatternBytecode` con instrucciones

**Estrategias de compilaciÃ³n clave:**

1. **Literals** (`5`, `"hello"`, `Pi`):
   ```
   MATCH_LITERAL %e0, <value>, L_fail
   ```

2. **Blanks** (`_`, `_Integer`):
   ```
   MATCH_HEAD %e0, Integer, L_fail
   ```

3. **Patrones con Nombre** (`x_`, `x_Integer`):
   - Primera ocurrencia: Emparejar, luego vincular
   - Ocurrencia repetida: Verificar igualdad con *binding* previo
   ```
   ; First x_:
   MATCH_HEAD %e0, Integer, L_fail
   MOVE %e3, %e0
   BIND_VAR "Global`x", %e3
   
   ; Second x_:
   SAMEQ %b1, %e3, %e0
   BRANCH_FALSE %b1, L_fail
   ```

4. **Alternativas** (`p1 | p2 | p3`):
   ```
   TRY L_p2           ; Create choice point
   [compile p1]
   FAIL               ; Backtrack if p1 fails
   
   L_p2:
   RETRY L_p3         ; Update choice point
   [compile p2]
   FAIL
   
   L_p3:
   TRUST              ; Last alternative
   [compile p3]
   ```

5. **Patrones Estructurados** (`f[x_, y_]`):
   - Verificar longitud y cabeza (*head*)
   - Extraer y emparejar cada parte
   - Restaurar `%e0` entre emparejamientos de partes

**GestiÃ³n del estado del compilador:**
- `CompilerState` rastrea: registros, etiquetas, entorno lÃ©xico
- Entorno lÃ©xico (`st.lexical`): Mapea nombres de variables a registros
- Crucial para detectar variables repetidas (`f[x_, x_]`)

### 3.2 *Back-End*: EjecuciÃ³n de la MÃ¡quina Virtual

**File:** VirtualMachine.cpp

La VM ejecuta bytecode con soporte de *backtracking*:

**Runtime state:**
```cpp
struct VirtualMachine {
    // Execution state
    size_t pc;                        // Program counter
    std::vector<Expr> exprRegs;       // Expression registers
    std::vector<bool> boolRegs;       // Boolean registers
    
    // Scoping
    std::vector<Frame> frames;        // Frame stack (lexical scopes)
    Frame resultFrame;                // Final bindings
    
    // Backtracking
    std::vector<ChoicePoint> choiceStack;  // Choice points
    std::vector<TrailEntry> trail;         // Undo log
};
```

**Modelo de ejecuciÃ³n:**
1. Cargar bytecode y expresiÃ³n de entrada en `%e0`
2. Ejecutar instrucciones secuencialmente (bucle dirigido por PC)
3. En fallo de `MATCH_*`: Saltar a etiqueta de fallo
4. En `FAIL`: Hacer *backtrack* al *choice point* mÃ¡s reciente
5. En `HALT`: Retornar resultado desde `%b0`

**Mecanismo de *backtracking*:**
```cpp
bool backtrack() {
    if (choiceStack.empty()) return false;  // Permanent failure
    
    auto& cp = choiceStack.back();
    
    // Restore state
    exprRegs = cp.savedExprRegs;
    boolRegs = cp.savedBoolRegs;
    
    // Restore frames
    while (frames.size() > cp.frameMark)
        frames.pop_back();
    
    // Undo bindings
    unwindTrail(cp.trailMark);
    
    // Jump to next alternative
    pc = resolveLabel(cp.nextAlternative);
    
    return true;  // Choice point remains! (RETRY/TRUST remove it)
}
```

### 3.3 Estructura de Datos

**MExpr (AST Interno):**
```cpp
class MExpr {
    enum Kind { Literal, Symbol, Normal };
    virtual Expr getExpr() const = 0;
    virtual Kind getKind() const = 0;
};

class MExprNormal : public MExpr {
    std::shared_ptr<MExpr> head;
    std::vector<std::shared_ptr<MExpr>> children;
    // Represents f[a, b, c]
};
```

**PatternBytecode:**
```cpp
struct Instruction {
    Opcode opcode;
    std::vector<Operand> ops;  // Variant: ExprReg, BoolReg, Label, Ident, Imm
};

class PatternBytecode {
    std::vector<Instruction> instructions;
    std::unordered_map<Label, size_t> labelMap;  // Label â†’ PC
    
    void addLabel(Label L);
    std::optional<size_t> resolveLabel(Label L) const;
};
```

***Frame* (*Lexical Scope*):**
```cpp
struct Frame {
    using Bindings = std::unordered_map<std::string, Expr>;
    Bindings bindings;  // Variable name â†’ Bound value
    
    void bindVariable(const std::string& name, const Expr& value);
    std::optional<Expr> getVariable(const std::string& name) const;
};
```

**ChoicePoint (Estado de *Backtracking*):**
```cpp
struct ChoicePoint {
    size_t returnPC;              // PC when created (debug)
    size_t nextAlternative;       // Label to jump to on FAIL
    std::vector<Expr> savedExprRegs;
    std::vector<bool> savedBoolRegs;
    size_t trailMark;             // Trail size to restore to
    size_t frameMark;             // Frame depth to restore to
};
```

---

## 4. Aspectos Destacados de la ImplementaciÃ³n

### 4.1 *Backtracking* para *Alternatives*

**Protocolo de tres instrucciones:**
- **TRY**: "AquÃ­ hay una alternativa; si falla, intenta la siguiente"
- **RETRY**: "Actualiza el *choice point* guardado para intentar una alternativa diferente despuÃ©s"
- **TRUST**: "Ãšltima alternativa; no mÃ¡s *backtracking* despuÃ©s de esto"

Los *choice points* persisten a travÃ©s de `FAIL` hasta que `TRUST` los remueve.

**DesafÃ­o:** Implementar `p1 | p2 | p3` con intentos de alternativas independientes.

**SoluciÃ³n:** *Choice points* estilo WAM con protocolo de tres instrucciones:

1. **TRY** (primera alternativa):
   - Crea *choice point*
   - Guarda estado completo de la VM
   - Registra etiqueta de siguiente alternativa

2. **RETRY** (alternativas intermedias):
   - Actualiza la siguiente alternativa del *choice point*
   - No crea/remueve *choice points*

3. **TRUST** (Ãºltima alternativa):
   - Remueve *choice point*
   - Se compromete a esta alternativa

**Ejemplo de *bytecode* para `_Real | _Integer`:**
```
L0:  BEGIN_BLOCK L0
     TRY L4                    ; Create choice point â†’ L4

L3:  MATCH_HEAD %e0, Real, L5
     JUMP L2                   ; Success!
L5:  FAIL                      ; Backtrack to L4

L4:  TRUST                     ; Last alternative (remove choice point)
     MATCH_HEAD %e0, Integer, L1
     JUMP L2                   ; Success!

L1:  DEBUG_PRINT "Pattern failed"
     LOAD_IMM %b0, 0
     HALT

L2:  DEBUG_PRINT "Pattern succeeded"
     EXPORT_BINDINGS
     LOAD_IMM %b0, 1
     HALT
```

**Diagrama de TransiciÃ³n para `5` (Integer):**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BEGIN_BLOCK â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     TRY     â”‚â”€â”€â”€â”€â”€â–¶â”‚ ChoicePoint created  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â”‚ nextAlt = L4         â”‚
       â”‚             â”‚ saved: regs, frames  â”‚
       â–¼             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MATCH_HEAD  â”‚
â”‚ Real?       â”‚â”€â”€â”€âœ— FAIL
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    FAIL     â”‚â”€â”€â”€â”€â”€â–¶â”‚ backtrack()          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚ restore state        â”‚
                     â”‚ pc = L4              â”‚
                     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚   TRUST     â”‚â”€â”€â–¶ Pop choice point
                     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚ MATCH_HEAD  â”‚
                     â”‚ Integer?    â”‚â”€â”€â”€âœ“ SUCCESS
                     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚    HALT     â”‚â”€â”€â–¶ Return True
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Traxa de ejecuciÃ³n para entrada `5` (Integer):**
```
1. BEGIN_BLOCK L0          â†’ frames = [Frame{}]
2. TRY L4                  â†’ choiceStack = [ChoicePoint{nextAlt=L4, ...}]
3. MATCH_HEAD Real         â†’ FAIL (5 is not Real)
4. FAIL                    â†’ backtrack()
   - Restore registers
   - pc = L4
5. TRUST                   â†’ choiceStack.pop()
6. MATCH_HEAD Integer      â†’ SUCCESS (5 is Integer)
7. JUMP L2                 â†’ Success block
8. EXPORT_BINDINGS         â†’ Copy bindings to result
9. HALT                    â†’ Return True
```

### 4.2 Variables Repetidas

En patrones como `f[x_, x_]`, ambas ocurrencias de `x` deben emparejar el mismo valor. Manejamos esto mediante seguimiento del entorno lÃ©xico en tiempo de compilaciÃ³n:

Seguimiento del entorno lÃ©xico en **tiempo de compilaciÃ³n**:

```cpp
static void compilePattern(CompilerState& st, ...) {
    std::string varName = getVariableName(mexpr);
    
    auto it = st.lexical.find(varName);
    if (it != st.lexical.end()) {
        // REPEATED VARIABLE: x already seen
        ExprRegIndex storedReg = it->second;  // Where first x was stored
        
        // Generate: Check if current value equals stored value
        BoolRegIndex b = st.allocBoolReg();
        st.emit(Opcode::SAMEQ, { OpBoolReg(b), OpExprReg(storedReg), OpExprReg(0) });
        st.emit(Opcode::BRANCH_FALSE, { OpBoolReg(b), OpLabel(failLabel) });
        
        // ... compile subpattern ...
    } else {
        // FIRST OCCURRENCE: Bind x
        // ... compile subpattern first ...
        ExprRegIndex bindReg = st.allocExprReg();
        st.emit(Opcode::MOVE, { OpExprReg(bindReg), OpExprReg(0) });
        st.lexical[varName] = bindReg;  // Track for later
        st.emit(Opcode::BIND_VAR, { OpIdent(varName), OpExprReg(bindReg) });
    }
}
```

**Ejemplo para `f[x_, x_]` coincidiendo con `f[5, 5]`:**
```
MATCH_LENGTH %e0, 2, L_fail
MATCH_HEAD %e0, f, L_fail
MOVE %e1, %e0                  ; Save f[5,5]

; Match first x_:
GET_PART %e2, %e0, 1          ; %e2 = 5
MOVE %e0, %e2                 ; %e0 = 5 (current value)
MOVE %e3, %e0                 ; %e3 = 5 (bind register)
BIND_VAR "Global`x", %e3      ; x â†’ 5
MOVE %e0, %e1                 ; Restore %e0 = f[5,5]

; Match second x_:
GET_PART %e4, %e0, 2          ; %e4 = 5
MOVE %e0, %e4                 ; %e0 = 5
SAMEQ %b1, %e3, %e0              ; %b1 = (%e3 == %e0) = (5 == 5) = True
BRANCH_FALSE %b1, L_fail      ; Don't jump (condition is True)
; ... success ...
```

---

## 5. Capacidades Actuales

### 5.1 Tipos de Patrones Soportados

**Patrones BÃ¡sicos:**
âœ… **Literales:** `5`, `1.5`, `"hello"`, `Pi`
âœ… ***Blanks*:** `_`, `_Integer`, `_Real`, `_f`
âœ… **Patrones con Nombre:** `x_`, `x_Integer` (vincular variable al valor emparejado)

**Patrones Avanzados:**
âœ… **Variables Repetidas:** `f[x_, x_]` (ambas ocurrencias deben ser iguales)
âœ… **Alternativas:** `p1 | p2 | p3` (con *backtracking*)
âœ… **Patrones Estructurados:** `f[x_, y_]`, `{a_, b_, c_}`, patrones anidados

**Composiciones Complejas:**
âœ… `f[x_Integer | x_Real, x_]` (alternativas + variables repetidas)
âœ… `{a_, {b_, a_}}` (anidamiento + repeticiÃ³n)

### 5.2 AÃšN NO Soportados

âŒ **Sequence Patterns:**
- `__` (uno o mÃ¡s)
- `___` (cero o mÃ¡s)
- `x__Integer` (sequencia de enteros vinculada a `x`)

ğŸ”„ **Patrones Condicionales (EN PROGRESO):**
- `x_?test` (patrÃ³n con funciÃ³n de prueba) - **IMPLEMENTANDO**
- `x_ /; x > 0` (patrÃ³n con condiciÃ³n)

âŒ **Patrones Opcionales:**
- `x_.` (opcional con valor por defecto)
- `f[x_, y_:0]` (valores por defecto)

âŒ **CaracterÃ­sticas Avanzadas:**
- `Verbatim[_]` (coincidir con *blank* literal)
- `HoldPattern[...]` (prevenir evaluaciÃ³n)
- Coincidencia `Orderless`
- Optimizacione de patrones (e.g., pre-filtrado de *literals*)

### 5.3 ComparaciÃ³n de CaracterÃ­sticas con MatchQ Nativo

| Tipo de PatrÃ³n | `MatchQ` Nativo | PatternMatcherVM | Notas |
|--------------|-----------------|------------------|-------|
| Literals (`5`, `"hello"`) | âœ… | âœ… | Soporte completo |
| Blanks (`_`, `_Integer`) | âœ… | âœ… | Soporte completo |
| Named patterns (`x_`) | âœ… | âœ… | Soporte completo |
| Repeated variables (`f[x_, x_]`) | âœ… | âœ… | Soporte completo |
| Alternatives (`\|`) | âœ… | âœ… | Soporte completo con *backtracking* |
| Sequences (`__`, `___`) | âœ… | âŒ | Fase 3 |
| Pattern test (`_?test`) | âœ… | ğŸ”„ | En progreso |
| Conditions (`/;`) | âœ… | âŒ | Fase 3 |
| Optional (`_.`) | âœ… | âŒ | Fase 3 |
| Orderless | âœ… | âŒ | Trabajo futuro |

---

## 6. Ejemplos

### 6.1 Ejemplo 1: PatrÃ³n Simple con Variable Repetida

**PatrÃ³n:** `{x_, x_}`  
**Entrada:** `{5, 5}`

**CompilaciÃ³n:**
```wolfram
bytecode = CompilePatternToBytecode[{x_, x_}]
```

**Bytecode Generado (simplificado):**
```
L0:  BEGIN_BLOCK L0
     MATCH_LENGTH %e0, 2, L_fail      ; Check length == 2
     MATCH_HEAD %e0, List, L_fail     ; Check head == List
     MOVE %e1, %e0                    ; Save {5,5}
     
     ; First x_:
     GET_PART %e2, %e0, 1             ; %e2 = 5
     MOVE %e0, %e2
     MOVE %e3, %e0                    ; %e3 = 5 (binding register)
     BIND_VAR "Global`x", %e3
     MOVE %e0, %e1
     
     ; Second x_:
     GET_PART %e4, %e0, 2             ; %e4 = 5
     MOVE %e0, %e4
     SAMEQ %b1, %e3, %e0                 ; 5 == 5 ?
     BRANCH_FALSE %b1, L_fail         ; Jump if not equal
     
     END_BLOCK L0
     JUMP L_success

L_fail:
     DEBUG_PRINT "Pattern failed"
     LOAD_IMM %b0, 0
     HALT

L_success:
     DEBUG_PRINT "Pattern succeeded"
     EXPORT_BINDINGS                  ; Result: {x â†’ 5}
     LOAD_IMM %b0, 1
     HALT
```

**EjecuciÃ³n:**
```wolfram
(* Create VM and load bytecode *)
In[1]:= vm = CreatePatternMatcherVirtualMachine[]
Out[1]= PatternMatcherLibrary`VM`VirtualMachine[<...>]

In[2]:= bytecode = CompilePatternToBytecode[{x_, x_}]
Out[2]= PatternMatcherLibrary`VM`PatternBytecode[<...>]

In[3]:= vm["initialize", bytecode]

(* Match against input *)
In[4]:= vm["match", {5, 5}]
Out[4]= True

(* Get bindings *)
In[5]:= vm["getResultBindings"]
Out[5]= <|"Global`x" -> 5|>
```

**O usar la interfaz de alto nivel:**
```wolfram
In[1]:= PatternMatcherExecute[{x_, x_}, {5, 5}]
Out[1]= <|
  "Result" -> True, 
  "CyclesExecuted" -> 22, 
  "Bindings" -> <|"Global`x" -> 5|>
|>
```

### 6.2 Ejemplo 2: Alternativas con *Backtracking*

**PatrÃ³n:** `_Real | _Integer`  
**Entradas:** `1.5` (Real), `5` (Integer), `"text"` (String)

**CompilaciÃ³n:**
```wolfram
bytecode = CompilePatternToBytecode[Alternatives[_Real, _Integer]]
```

***Bytecode* Generado:**
```
L0:  BEGIN_BLOCK L0
     TRY L4                           ; Create choice point â†’ try Integer

L3:  ; First alternative: _Real
     MATCH_HEAD %e0, Real, L5
     JUMP L_success
L5:  FAIL                             ; Backtrack

L4:  ; Second alternative: _Integer
     TRUST                            ; Last alternative
     MATCH_HEAD %e0, Integer, L_fail
     JUMP L_success

L_fail:
     DEBUG_PRINT "Pattern failed"
     LOAD_IMM %b0, 0
     HALT

L_success:
     DEBUG_PRINT "Pattern succeeded"
     EXPORT_BINDINGS
     LOAD_IMM %b0, 1
     HALT
```

**Trazas de EjecuciÃ³n:**

**Input: `1.5` (Real)**
```
1. TRY L4              â†’ Crear choice point
2. MATCH_HEAD Real     â†’ Ã‰XITO (1.5 es Real)
3. JUMP L_success      â†’ Coincidencia tiene Ã©xito
```

**Input: `5` (Integer)**
```
1. TRY L4              â†’ Crear choice point
2. MATCH_HEAD Real     â†’ FALLO (5 no es Real)
3. FAIL                â†’ backtrack() â†’ pc = L4
4. TRUST               â†’ Remover choice point
5. MATCH_HEAD Integer  â†’ SUCCESS (5 es Integer)
6. JUMP L_success      â†’ Coincidencia tiene Ã©xito
```

**Input: `"text"` (String)**
```
1. TRY L4              â†’ Crear choice point
2. MATCH_HEAD Real     â†’ FALLO (String no es Real)
3. FAIL                â†’ backtrack() â†’ pc = L4
4. TRUST               â†’ Remover choice point
5. MATCH_HEAD Integer  â†’ FALLO (String no es Integer)
6. JUMP L_fail         â†’ Coincidencia no tiene Ã©xito
```

### 6.3 Ejemplo 3: PatrÃ³n Anidado Complejo

**PatrÃ³n:** `f[x_Integer | x_Real, x_]`  
**Entrada:** `f[5, 5]`

**SemÃ¡ntica:**
- Primer argumento: `x` debe ser un Integer **o** Real
- Secondo argumento: `x` (debe ser igual al primer argumento)

***Bytecode* Generado:**
```
BEGIN_BLOCK
MATCH_LENGTH 2
MATCH_HEAD f
MOVE %e1, %e0                    ; Save f[5,5]

; First argument: x_Integer | x_Real
GET_PART %e2, %e0, 1
MOVE %e0, %e2                    ; %e0 = 5

  TRY L_alt2
L_alt1:  ; x_Integer
    MATCH_HEAD Integer, L_fail_alt1
    MOVE %e3, %e0                ; %e3 = 5
    BIND_VAR "Global`x", %e3
    JUMP L_after_alternatives
L_fail_alt1:
    FAIL

L_alt2:  ; x_Real
    TRUST
    MATCH_HEAD Real, L_fail
    MOVE %e3, %e0
    BIND_VAR "Global`x", %e3

L_after_alternatives:
MOVE %e0, %e1                    ; Restore f[5,5]

; Second argument: x_
GET_PART %e4, %e0, 2
MOVE %e0, %e4                    ; %e0 = 5
SAMEQ %b1, %e3, %e0                 ; 5 == 5 ?
BRANCH_FALSE %b1, L_fail

END_BLOCK
JUMP L_success
```

**EjecuciÃ³n para `f[5, 5]`:**
1. Verificar estructura: longitud=2, cabeza=f âœ“
2. Extraer primer argumento: `5`
3. Intentar `x_Integer`: Ã‰XITO, vincular `x â†’ 5`
4. Extraer segundo argumento: `5`
5. Verificar `x == 5`: VERDADERO âœ“
6. **Resultado:** La coincidencia tiene Ã©xito, `x â†’ 5`

**EjecuciÃ³n para `f[1.5, 1.5]`:**
1. Verificar estructura âœ“
2. Extraer primer argumento: `1.5`
3. Intentar `x_Integer`: FALLO
4. Hacer *backtrack*, intentar `x_Real`: Ã‰XITO, bind `x â†’ 1.5`
5. Extraer segundo argumento: `1.5`
6. Verificar `x == 1.5`: VERDADERO âœ“
7. **Resultado:** La coincidencia tiene Ã©xito, `x â†’ 1.5`

**EjecuciÃ³n para `f[5, 10]`:**
1. Verificar estructura âœ“
2. Extraer primer argumento: `5`
3. Intentar `x_Integer`: Ã‰XITO, vincular `x â†’ 5`
4. Extraer segundo argumento: `10`
5. Verificar `x == 10`: FALSO âœ—
6. **Resulto:** Coincidencia **falla**

---

## 7. Consideraciones de Rendimiento

### 7.1 Estado Actual de la ImplementaciÃ³n

**Completado:**
- âœ… ImplementaciÃ³n funcional en C++ con todas las caracterÃ­sticas principales
- âœ… EjecuciÃ³n basada en registros (sin overhead de pila)
- âœ… *Backtracking* con *choice points* funcionando correctamente
- âœ… OptimizaciÃ³n del *trail* (solo cuando es necesario)
- âœ… Soporte comprehensivo de *logging*/depuraciÃ³n

**AÃºn No Optimizados:**
- â³ Sin pases de optimizaciÃ³n de *bytecode*
- â³ Sin fusiÃ³n de instrucciones u optimizaciÃ³n *peephole*
- â³ Sin cachÃ© de precompilaciÃ³n de patrones
- â³ Sin rutas rÃ¡pidas especializadas para patrones comunes

### 7.2 Optimizaciones Planeadas (Fase 3)

**Optimizaciones a nivel de IR:**
- **Dead code elimination:** Remover alternativas inalcanzables
- **Constant folding:** Precomputar resultados de `MATCH_LITERAL`
- **EliminaciÃ³n de subexpresiones comunes:** Reusar resultados de `GET_PART`

**Optimizaciones de *bytecode*:**
- **FusiÃ³n de instrucciones:** Combinar `GET_PART` + `MOVE` â†’ `GET_PART_TO`
- **AsignaciÃ³n de registros:** Minimizar conteo de registros
- **Literal pooling:** Compartir constantes `Expr` comunes

**Optimizaciones de *runtime*:**
- **Ruta rÃ¡pida para patrones sin *backtracking***: Omitir el *trail* completamente
- **Inlining de patrones pequeÃ±os:** Compilar a funciones nativas
- **Coincidencias especializadas:** CÃ³digo optimizado para `_Integer`, `_Real`, etc.


### 7.3 MÃ©tricas de EvaluaciÃ³n (Fase 3)

Esta tesis evalÃºa la VM usando **mÃ©tricas intrÃ­nsecas** (no benchmarks comparativos):

**1. MÃ©tricas de Calidad del Bytecode:**
   - Conteo de instrucciones (*opcodes* totales por patrÃ³n)
   - Uso de registros (asignaciÃ³n pico)
   - Densidad de cÃ³digo (instrucciones por construcciÃ³n de patrÃ³n)
   - Complejidad del flujo de control (conteo de etiquetas)

**2. MÃ©tricas de *Runtime*:**
   - Ciclos de ejecuciÃ³n (instrucciones ejecutadas por coincidencia)
   - Eventos de *backtracking* (*choice points* creados/restaurados)
   - Actividad del *trail* (*bindings* hechos/deshechos)
   - Huella de memoria (tamaÃ±o de *bytecode*, registros pico, profundidad mÃ¡xima de *frames*)

**3. MÃ©tricas de CompilaciÃ³n:**
   - Tiempo de compilaciÃ³n (patrÃ³n â†’ *bytecode*)
   - Escalamiento de complejidad (simple vs. alternativas vs. anidado)

**Â¿Por quÃ© mÃ©tricas intrÃ­nsecas?** Miden las caracterÃ­sticas de la VM directamente, independientes del rendimiento de `MatchQ` nativo.

---

## 8. PrÃ³ximos Pasos

### 8.1 Prioridades Immediatas (Noviembre 2025)

**1. Completar ImplementaciÃ³n de `PatternTest`**
   - Agregar *opcode* `PATTERN_TEST`
   - Soportar sintaxis `_?test`
   - Integratar con *backtracking*
   - **Entregable:** `PatternTest` funcional con pruebas

**2. Actualizar DocumentaciÃ³n del *Paclet***
   - Refrescar pÃ¡ginas de referencia de sÃ­mbolos
   - Agregar ejemplos para nuevas caracterÃ­sticas (alternativas, *backtracking*)
   - Actualizar pÃ¡ginas de guÃ­a
   - **Entregable:** DocumentaciÃ³n actualizada en [PatternMatcherVM paclet](https://www.wolframcloud.com/obj/daniels/DeployedResources/Paclet/DanielS/PatternMatcherVM/)

**3. RecolecciÃ³n de MÃ©tricas de EjecuciÃ³n**
   - Implementar contador de ciclos y *hooks* de perfilado
   - Agregar reporte de estadÃ­sticas de *bytecode*
   - Medir huella de memoria (registros, *frames*, *choice points*)
   - Generar trazas de ejecuciÃ³n para anÃ¡lisis
   - **Entregable**: *Framework* de recolecciÃ³n de mÃ©tricas para CapÃ­tulo 5

**4. Suite de Pruebas Comprehensiva**
   - Expandir archivos de prueba `.mt` con casos extremos
   - Agregar pruebas de equivalencia: `MatchQ[expr, patt] === PatternMatcherMatchQ[patt, expr]`
   - Probar todos los tipos de patrones soportados sistemÃ¡ticamente
   - **Entregable:** Cobertura de patrones 90%+ en suite de pruebas

### 8.2 Fase 3: OptimizaciÃ³n y ValidaciÃ³n (Dic 2025)

**Patrones de Sequencia (`__`, `___`):**
- DiseÃ±ar representaciÃ³n de *bytecode* para secuencias de longitud variable
- Implementar emparejamiento *greedy*/*non-greedy*
- Agregar familia de opcodes `MATCH_SEQUENCE`

**Patrones Condicionales (`x_ /; cond`):**
- Compilar condiciÃ³n a *bytecode* o *callback*
- Agregar opcode `TEST_CONDITION`
- Integrar con *backtracking* (fallo de condiciÃ³n dispara *backtrack*)

**Optimizador de *Bytecode*:**
- Implementar pases de optimizaciÃ³n:
  - EliminaciÃ³n de cÃ³digo muerto
  - PropagaciÃ³n de constantes
  - AsignaciÃ³n de registros
- Medir impacto en velocidad de ejecuciÃ³n

**Metrics Analysis:**
- Recolectar estadÃ­sticas de *bytecode* entre tipos de patrones
- Medir ciclos de ejecuciÃ³n para patrones representativos
- Perfilar uso de memoria (registros, *frames*, *choice points*, *trail*)
- Analizar overhead de *backtracking*
- Documentar compromisos y decisiones de diseÃ±o

### 8.3 Fase 4: DocumentaciÃ³n y Tesis (Nov 2025 - Ene 2026)

**TÃ­tulo**: *Una MÃ¡quina Virtual para el Pattern Matcher de Wolfram Language*

**Estructura de Tesis:**

1. **IntroducciÃ³n** (EN PROGRESO)
   - MotivaciÃ³n: Â¿Por quÃ© compilar *pattern matching*?
   - Planteamiento del problema: Cuellos de botella de rendimiento en *matcher* nativo
   - Contribuciones: VM basada en registros con *backtracking*

2. **Antecedentes** (EN PROGRESO)
   - *Pattern matching* en lenguajes funcionales
   - Arquitecturas de mÃ¡quinas virtuales (pila vs. registros)
   - Warren *Abstract Machine* (WAM) para Prolog

3. **DiseÃ±o** (EN PROGRESO)
   - 3.1 Pipeline de CompilaciÃ³n
      - Flujo PatrÃ³n â†’ AST â†’ *Bytecode*
      - CompilaciÃ³n multi-pase vs. pase-Ãºnico
   - 3.2 Arquitectura del Conjunto de Instrucciones
      - Principios de diseÃ±o (ortogonalidad, fusiÃ³n)
      - ComparaciÃ³n con otros ISAs (WAM, Lua, JVM)
   - 3.3 Mecanismo de *Backtracking*
      - *Choice points* y *trail*
      - Protocolo `TRY`/`RETRY`/`TRUST`
   - 3.4 AsignaciÃ³n de Registros
      - Estrategia de asignaciÃ³n estÃ¡tica
      - Registros de expresiones vs. booleanos
   - 3.5 GestiÃ³n de *Frames*
      - Alcance lÃ©xico con *frames*
      - PropagaciÃ³n y fusiÃ³n de *bindings*

4. **ImplementaciÃ³n** (PLANEADO)
   - Estructura de cÃ³digo base en C++
   - Compilador de *bytecode* (`CompilePatternToBytecode`)
   - MÃ¡quina virtual (`VirtualMachine`)
   - IntegraciÃ³n con Wolfram Language (via LibraryLink)

5. **MÃ©tricas** (PLANEADO)
   - 5.1 Pruebas de Correctitud
     - Equivalence with `MatchQ` for supported patterns
     - Edge case coverage
   - 5.2 AnÃ¡lisis de *Bytecode*
     - Conteo de instrucciones vs. complejidad de patrÃ³n
     - Eficiencia de asignaciÃ³n de registros
     - MÃ©tricas de densidad de cÃ³digo
   - 5.3 CaracterÃ­sticas de EjecuciÃ³n
     - Conteos de ciclos para clases de patrones
     - AnÃ¡lisis de *overhead* de *backtracking*
     - Mediciones de huella de memoria
   - 5.4 DiscusiÃ³n
     - Compromisos (tiempo de compilaciÃ³n vs. ejecuciÃ³n)
     - Â¿CuÃ¡ndo es beneficioso el enfoque de VM?
     - Limitaciones y fuentes de *overhead*

6. **ConclusiÃ³n** (PLANEADO)
   - Resumen de contribuciones
   - Limitaciones y trabajo futuro
   - Implicaciones mÃ¡s amplias para optimizaciÃ³n de Wolfram Language

### 8.4 Direcciones Futuras

**Advanced Features:**
- **CompilaciÃ³n JIT**: Traducir rutas calientes de *bytecode* a cÃ³digo nativo
- **EspecializaciÃ³n de Patrones**: Generar cÃ³digo optimizado para clases de patrones
- **Emparejamiento Paralelo**: EjecuciÃ³n multi-hilo para alternativas independientes
- **IndexaciÃ³n de Patrones**: Preprocesar expresiones para emparejamiento mÃ¡s rÃ¡pido

**Extensiones del Lenguaje:**
- **Macros de Patrones:** Combinadores de patrones definidos por usuario
- **Emparejadores Personalizados:** Arquitectura de *plugins* para patrones especÃ­ficos de dominio
- **AnÃ¡lisis EstÃ¡tico:** ValidaciÃ³n de patrones en tiempo de compilaciÃ³n y sugerencias de optimizaciÃ³n

**IntegraciÃ³n:**
- **Sistemas basados en reglas:** Extender a `ReplaceAll`, `ReplaceRepeated`
- **Tablas de dispatch:** Optimizar emparejamiento de mÃºltiples patrones
- **ComputaciÃ³n simbÃ³lica:** Integrar con simplificaciÃ³n de expresiones

---

## 9. ConclusiÃ³n

### 9.1 Resumen de Logros

Hemos construido exitosamente una **mÃ¡quina virtual de pattern matching** completamente funcional con:

âœ… **ImplementaciÃ³n funcional:** 3,250 lÃ­neas de C++, completamente funcional
âœ… **ISA mÃ­nimo:** 20 *opcodes* (reducidos desde 30+ en diseÃ±os tempranos)
âœ… **Backtracking completo:** *Choice points* estilo WAM con `TRY`/`RETRY`/`TRUST`
âœ… **SemÃ¡ntica correcta:** Equivalencia probada contra `MatchQ` nativo
âœ… **Cobertura de patrones:** 6/12 tipos principales (literales, *blanks*, alternativas, etc.)
âœ… **IntegraciÃ³n de producciÃ³n:** LibraryLink + paclet de Wolfram desplegado

### 9.2 Innovaciones Principales

1. **Operaciones de Emparejamiento Fusionadas**
   - `MATCH_HEAD`, `MATCH_LENGTH`, `MATCH_LITERAL` combinan prueba + rama
   - Reduce conteo de instrucciones y mejora localidad

2. **Protocolo de *Backtracking* ExplÃ­cito**
   - `TRY` / `RETRY` / `TRUST` / `FAIL` hacen el flujo de control explÃ­cito
   - MÃ¡s claro que desenrollado implÃ­cito de pila

3. **GestiÃ³n LÃ©xica en Tiempo de CompilaciÃ³n**
   - RestauraciÃ³n de entorno lÃ©xico para alternativas independientes
   - Habilita manejo correcto de `x_Integer | x_Real`

4. **OptimizaciÃ³n del *Trail***
   - Solo hacer *trail* cuando existen *choice points*
   - Ganancia significativa de rendimiento para patrones sin *backtracking*

5. **Convenciones de Registros**
   - `%e0` = valor actual, `%b0` = resultado
   - Simplifica generaciÃ³n de cÃ³digo y depuraciÃ³n

### 9.3 Lecciones Aprendidas

**Arquitectura:**
- Las VMs basadas en registros son mÃ¡s complejas que las basadas en pila, pero valen la pena por rendimiento
- El *backtracking* explÃ­cito (estilo WAM) es mÃ¡s claro que el desenrollado basado en excepciones
- La gestiÃ³n de *frames* requiere balance cuidadoso (alcance vs. *overhead*)

**ImplementaciÃ³n:**
- El *logging* comprehensivo es esencial para depurar internos de VM
- Comenzar con casos simples, luego agregar complejidad incrementalmente
- Probar casos extremos temprano (patrones vacÃ­os, profundamente anidados, etc.)

**IntegraciÃ³n con Wolfram:**
- LibraryLink funciona bien para integraciÃ³n de bajo nivel con C++
- La API `Expr` provee buena abstracciÃ³n sobre expresiones de Wolfram
- Los objetos embebidos habilitan API limpia estilo OOP desde Wolfram

### 9.4 Estado del Proyecto

**LÃ­nea de Tiempo:** En camino para defensa de tesis en **Enero 2026**

**Progreso de Fases:**
- âœ… Fase 1 (InvestigaciÃ³n): **COMPLETA**
- âœ… Fase 2 (Stack VM): **COMPLETA**
- âœ… Fase 2A (ImplementaciÃ³n en C++): **COMPLETA**
- ğŸ”„ Fase 2B (*Feature Completion*): **EN PROGRESO**
  - âœ… *Backtracking* & alternativas
  - âœ… Variables repetidas
  - ğŸ”„ ImplementaciÃ³n de `PatternTest`
  - â³ ActualizaciÃ³n de documentaciÃ³n
- â³ Fase 3 (OptimizaciÃ³n): **PLANEADA (Dic 2025)**
- ğŸ”„ Fase 4 (Escritura de Tesis): **EN PROGRESO**
  - âœ… CapÃ­tulos iniciales de borrador comenzados
  - ğŸ”„ Secciones de antecedentes y diseÃ±o en progreso
  - â³ CapÃ­tulo de implementaciÃ³n (objetivo: mediados de Dic)
  - â³ CapÃ­tulo de evaluaciÃ³n (objetivo: finales de Dic)

**Calidad del CÃ³digo:**
- **Bien documentado:** Cada archivo tiene comentarios comprehensivos
- **Modular:** SeparaciÃ³n clara entre compilador, VM, estructuras de datos
- **Probado:** Suite de pruebas bÃ¡sica en lugar, expandiendo a cobertura comprehensiva
- **Depurable:** Infraestructura extensa de *logging* y rastreo
- **Publicado:** CÃ³digo fuente disponible en [GitHub](https://github.com/daneelsan/WolframLanguagePatternMatcher/)
- **Desplegado:** DocumentaciÃ³n del *paclet* en [WolframCloud](https://www.wolframcloud.com/obj/daniels/DeployedResources/Paclet/DanielS/PatternMatcherVM/)

---

---

## Glosario

**Conceptos Principales:**
- ***Bytecode*:** RepresentaciÃ³n de bajo nivel de instrucciones de un patrÃ³n compilado
- **Registro:** UbicaciÃ³n de almacenamiento de VM para valores de expresiÃ³n o booleanos
- ****Backtracking*:** Deshacer intentos fallidos e intentar alternativas

**Componentes de la VM:**
- ***Choice Point*:** Estado guardado que habilita *backtracking* a siguiente alternativa
- ***Frame*:** Alcance lÃ©xico que contiene *bindings* de variables
- ***Trail*:** Registro de deshacer para revertir *bindings* durante *backtracking*
- ***Opcode*:** Tipo de instrucciÃ³n (e.g., `MATCH_HEAD`, `BIND_VAR`)

**Conceptos de Patrones:**
- ***Blank*:** ComodÃ­n de patrÃ³n (`_`) que empareja cualquier expresiÃ³n
- **Cabeza:** FunciÃ³n/sÃ­mbolo de nivel superior (e.g., `f` en `f[x, y]`)
- **Entorno LÃ©xicoo:** Mapeo en tiempo de compilaciÃ³n de nombres de variables a registros

**Referencia:**
- **WAM:** Warren Abstract Machine (modelo de ejecuciÃ³n de Prolog)

---

## ApÃ©ndice A: EstadÃ­sticas de CÃ³digo

**ImplementaciÃ³n en C++:**
```
src/VM/
  Opcode.h              ~450 lines (instruction set definition)
  Opcode.cpp            ~150 lines (opcode utilities)
  CompilePatternToBytecode.h    ~100 lines
  CompilePatternToBytecode.cpp  ~800 lines (compiler)
  VirtualMachine.h      ~250 lines (VM interface)
  VirtualMachine.cpp    ~600 lines (VM implementation)
  PatternBytecode.h/cpp ~300 lines (bytecode representation)

src/AST/
  MExpr.h/cpp           ~400 lines (AST classes)
  MExprPatternTools.h/cpp ~200 lines (pattern utilities)

Total: ~3,250 lines of C++ (excluding comments/whitespace)
```

**Interfaz de Wolfram Language:**
```
PatternMatcher/Kernel/
  BackEnd/VirtualMachine.wl        ~300 lines
  FrontEnd/CompilePatternToBytecode.wl ~200 lines
  PatternToMatchFunction.wl        ~150 lines
  
Total: ~650 lines of Wolfram Language
```

**Test Suite:**
```
tests/PatternMatcher/*.mt  ~500 lines
Total test cases: ~40 (expanding to 100+)
```

---

## ApÃ©ndice B: Referencias Clave

**Virtual Machine Design:**
- Hassan AÃ¯t-Kaci. *Warren's Abstract Machine: A Tutorial Reconstruction*. MIT Press, 1999.
- Roberto Ierusalimschy et al. *The Implementation of Lua 5.0*. Journal of Universal Computer Science, 2005.

**Pattern Matching:**
- Luc Maranget. *Compiling Pattern Matching to Good Decision Trees*. ML Workshop, 2008.
- Fabrice Le Fessant, Luc Maranget. *Optimizing Pattern Matching*. ICFP, 2001.

**Wolfram Language:**
- Stephen Wolfram. *An Elementary Introduction to the Wolfram Language*. Wolfram Media, 2015.
- Wolfram Research. *Wolfram Language Documentation: Pattern Matching*.
