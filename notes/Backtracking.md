# PatternMatcher VM Backtracking Strategy

## Introduction

The PatternMatcher VM is designed to support **full backtracking** for symbolic pattern matching, enabling powerful features such as `Alternatives`, `Repeated`, and complex nested patterns. This strategy is inspired by the **Warren Abstract Machine (WAM)**, the execution model underlying Prolog, which is renowned for its efficient and correct handling of non-deterministic computations.

---

## 1. VM Architecture for Backtracking

### Choice Points

- **Definition:** A choice point is a snapshot of the VM’s execution state, created before attempting a non-deterministic pattern (e.g., an alternative).
- **Contents:** Each choice point stores:
  - The program counter (pc) to resume execution
  - The label for the next alternative to try
  - Copies of all expression and boolean registers
  - The current position in the trail stack (for variable bindings)
  - The current frame depth (for variable scopes)

### Trail Stack

- **Purpose:** The trail records variable bindings that may need to be undone if the VM backtracks.
- **Mechanism:** When a variable is bound in a context where backtracking is possible, a trail entry is created. On backtracking, the VM unwinds the trail, reverting variable bindings to their previous state.

### Frames

- **Variable Scoping:** The VM uses a stack of frames, each mapping variable names to their bound values. When entering a new block (e.g., a pattern variable scope), a new frame is pushed. On block exit or backtracking, frames are popped as needed.

---

## 2. Backtracking Execution Flow

### Pattern Matching with Alternatives

For a pattern like `f[_Integer | _String]`, the VM will:

1. **Create a Choice Point:** Before trying the first alternative, the VM saves its state.
2. **Try First Alternative:** Attempt to match `_Integer`.
3. **On Failure:** If `_Integer` fails, the VM restores its state from the choice point and tries `_String`.
4. **On Success:** If any alternative succeeds, the VM commits (removes choice points) and continues.
5. **On Exhaustion:** If all alternatives fail, the pattern match fails.

### Variable Binding and Trail Management

- **Binding:** When a variable is bound in a backtrackable context, the binding is recorded in the trail.
- **Unwinding:** On backtracking, the VM undoes all bindings recorded in the trail since the choice point was created.

### Commit/Cut

- **Commit:** When a pattern match is certain (e.g., after a successful alternative), the VM can discard all choice points up to the current frame, preventing further backtracking.
- **Cut:** This operation is analogous to Prolog’s cut (`!`), used to optimize or enforce determinism.

---

## 3. VM Opcodes for Backtracking

| Opcode         | Description                                                      |
|----------------|------------------------------------------------------------------|
| `TRY <label>`  | Create a choice point and try the first alternative              |
| `RETRY <label>`| On failure, restore the choice point and try the next alternative|
| `TRUST`        | Last alternative; remove the choice point                        |
| `FAIL`         | Force backtracking to the most recent choice point               |
| `CUT`          | Remove all choice points up to the current frame                 |
| `TRAIL_BIND`   | Bind a variable and record it in the trail for undoing           |
| `SAVE_STATE`   | Explicitly save register state to the choice point               |
| `RESTORE_STATE`| Restore register state from the choice point                     |

---

## 4. Example: Bytecode for Alternatives

For `f[_Integer | _String]`, the generated bytecode might look like:

```
L0:  BEGIN_BLOCK L0
	TEST_LENGTH %b1, %e0, 2
	JUMP_IF_FALSE %b1, Lfail
	MATCH_HEAD %e0, Expr("f"), Lfail
	GET_PART %e1, %e0, 1

Lalt1: TRY Lalt2
	TEST_TYPE %e1, Integer
	JUMP_IF_FALSE %b2, Lfail
	TRUST
	JUMP Lsuccess

Lalt2: RETRY Lfail
	TEST_TYPE %e1, String
	JUMP_IF_FALSE %b3, Lfail
	TRUST
	JUMP Lsuccess

Lfail: DEBUG_PRINT "Pattern failed"
	 LOAD_IMM %b0, false
	 HALT

Lsuccess: DEBUG_PRINT "Pattern succeeded"
	    LOAD_IMM %b0, true
	    HALT
```

---

## 5. State Management

- **Choice Stack:** Maintains a stack of choice points for backtracking.
- **Trail:** Records variable bindings to be undone on backtracking.
- **Frames:** Manages variable scopes and lifetimes.
- **Registers:** Expression and boolean registers are saved/restored as part of choice points.

---

## 6. Design Inspiration

This strategy is directly inspired by the **Warren Abstract Machine (WAM)**, which is the backbone of Prolog’s execution model. WAM’s use of choice points and trail stacks enables efficient, correct backtracking and variable binding management in non-deterministic computations. Adapting these ideas to the PatternMatcher VM ensures robust and extensible pattern matching for symbolic computation.

**References:**
- [Warren Abstract Machine (Wikipedia)](https://en.wikipedia.org/wiki/Warren_Abstract_Machine)
- [Prolog and WAM: Tutorial](https://www.dcs.gla.ac.uk/~pat/Book/)

---

## 7. Benefits

- **Correctness:** Ensures all alternatives and repeated patterns are explored and variable bindings are properly managed.
- **Efficiency:** Only saves/restores necessary state, minimizing overhead.
- **Extensibility:** Supports advanced patterns and future optimizations.
- **Debuggability:** Choice points and trail can be inspected for troubleshooting and analysis.
